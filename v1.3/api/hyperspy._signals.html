

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>hyperspy._signals package &mdash; HyperSpy 1.3 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/hyperspy_logo.ico"/>
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="HyperSpy 1.3 documentation" href="../index.html"/>
        <link rel="up" title="hyperspy package" href="hyperspy.html"/>
        <link rel="next" title="hyperspy.datasets package" href="hyperspy.datasets.html"/>
        <link rel="prev" title="hyperspy._components package" href="hyperspy._components.html"/>
 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-25260850-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> HyperSpy
          

          
            
            <img src="../_static/hyperspy_logo.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                1.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../user_guide/index.html">HyperSpy User Guide (DRAFT)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Full HyperSpy API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="hyperspy.html">hyperspy package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="hyperspy.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="hyperspy._components.html">hyperspy._components package</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">hyperspy._signals package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.datasets.html">hyperspy.datasets package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.docstrings.html">hyperspy.docstrings package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.drawing.html">hyperspy.drawing package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.external.html">hyperspy.external package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.io_plugins.html">hyperspy.io_plugins package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.learn.html">hyperspy.learn package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.misc.html">hyperspy.misc package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.models.html">hyperspy.models package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.samfire_utils.html">hyperspy.samfire_utils package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.tests.html">hyperspy.tests package</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.utils.html">hyperspy.utils package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.Release">hyperspy.Release module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy._lazy_signals">hyperspy._lazy_signals module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.api">hyperspy.api module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.api_nogui">hyperspy.api_nogui module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.axes">hyperspy.axes module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.component">hyperspy.component module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.components1d">hyperspy.components1d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.components2d">hyperspy.components2d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.conftest">hyperspy.conftest module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.decorators">hyperspy.decorators module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.defaults_parser">hyperspy.defaults_parser module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.events">hyperspy.events module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.exceptions">hyperspy.exceptions module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.interactive">hyperspy.interactive module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.io">hyperspy.io module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.logger">hyperspy.logger module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.model">hyperspy.model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.roi">hyperspy.roi module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.samfire">hyperspy.samfire module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.signal">hyperspy.signal module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.signal_tools">hyperspy.signal_tools module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.signals">hyperspy.signals module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy.ui_registry">hyperspy.ui_registry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citing.html">Citing HyperSpy</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">HyperSpy</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">hyperspy</a> &raquo;</li>
        
          <li><a href="hyperspy.html">hyperspy package</a> &raquo;</li>
        
      <li>hyperspy._signals package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/hyperspy._signals.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="hyperspy-signals-package">
<h1>hyperspy._signals package<a class="headerlink" href="#hyperspy-signals-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-hyperspy._signals.common_signal1d">
<span id="hyperspy-signals-common-signal1d-module"></span><h2>hyperspy._signals.common_signal1d module<a class="headerlink" href="#module-hyperspy._signals.common_signal1d" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.common_signal1d.CommonSignal1D">
<em class="property">class </em><code class="descclassname">hyperspy._signals.common_signal1d.</code><code class="descname">CommonSignal1D</code><a class="headerlink" href="#hyperspy._signals.common_signal1d.CommonSignal1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Common functions for 1-dimensional signals.</p>
<dl class="method">
<dt id="hyperspy._signals.common_signal1d.CommonSignal1D.to_signal2D">
<code class="descname">to_signal2D</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.common_signal1d.CommonSignal1D.to_signal2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the one dimensional signal as a two dimensional signal.</p>
<p>Always ensures the data is stored optimally, hence often making a copy
of the data. See <cite>transpose</cite> for a more general method with more
options.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">transpose()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">as_signal1D()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">as_signal2D()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">hs.transpose()</span></code></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">DataDimensionError: when data.ndim &lt; 2</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.common_signal2d">
<span id="hyperspy-signals-common-signal2d-module"></span><h2>hyperspy._signals.common_signal2d module<a class="headerlink" href="#module-hyperspy._signals.common_signal2d" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.common_signal2d.CommonSignal2D">
<em class="property">class </em><code class="descclassname">hyperspy._signals.common_signal2d.</code><code class="descname">CommonSignal2D</code><a class="headerlink" href="#hyperspy._signals.common_signal2d.CommonSignal2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Common functions for 2-dimensional signals.</p>
<dl class="method">
<dt id="hyperspy._signals.common_signal2d.CommonSignal2D.to_signal1D">
<code class="descname">to_signal1D</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.common_signal2d.CommonSignal2D.to_signal1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the image as a spectrum.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="docutils">
<dt><code class="xref py py-meth docutils literal"><span class="pre">as_signal1D()</span></code></dt>
<dd>a method for the same purpose with more options.</dd>
<dt><code class="xref py py-meth docutils literal"><span class="pre">signals.Signal1D.to_signal1D()</span></code></dt>
<dd>performs the inverse operation on one</dd>
</dl>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">dimensional()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">as_signal2D()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">transpose()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">hs.transpose()</span></code></p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.complex_signal">
<span id="hyperspy-signals-complex-signal-module"></span><h2>hyperspy._signals.complex_signal module<a class="headerlink" href="#module-hyperspy._signals.complex_signal" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.complex_signal.ComplexSignal">
<em class="property">class </em><code class="descclassname">hyperspy._signals.complex_signal.</code><code class="descname">ComplexSignal</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal.ComplexSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.complex_signal.ComplexSignal_mixin" title="hyperspy._signals.complex_signal.ComplexSignal_mixin"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.complex_signal.ComplexSignal_mixin</span></code></a>, <a class="reference internal" href="hyperspy.html#hyperspy.signal.BaseSignal" title="hyperspy.signal.BaseSignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy.signal.BaseSignal</span></code></a></p>
<dl class="method">
<dt id="hyperspy._signals.complex_signal.ComplexSignal.angle">
<code class="descname">angle</code><span class="sig-paren">(</span><em>deg=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal.ComplexSignal.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle (also known as phase or argument). If the data is real, the angle is 0
for positive values and 2$pi$ for negative values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deg</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; Return angle in degrees if True, radians if False (default).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>angle</strong> &#8211; The counterclockwise angle from the positive real axis on the complex plane,
with dtype as numpy.float64.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">HyperSpy signal</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.complex_signal.ComplexSignal_mixin">
<em class="property">class </em><code class="descclassname">hyperspy._signals.complex_signal.</code><code class="descname">ComplexSignal_mixin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal.ComplexSignal_mixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>BaseSignal subclass for complex data.</p>
<dl class="attribute">
<dt id="hyperspy._signals.complex_signal.ComplexSignal_mixin.amplitude">
<code class="descname">amplitude</code><a class="headerlink" href="#hyperspy._signals.complex_signal.ComplexSignal_mixin.amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Get/set the amplitude of the data. Returns an
appropriate HyperSpy signal.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.complex_signal.ComplexSignal_mixin.angle">
<code class="descname">angle</code><span class="sig-paren">(</span><em>angle</em>, <em>deg=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal.ComplexSignal_mixin.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle (also known as phase or argument). If the data is real, the angle is 0
for positive values and 2$pi$ for negative values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deg</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; Return angle in degrees if True, radians if False (default).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>angle</strong> &#8211; The counterclockwise angle from the positive real axis on the complex plane,
with dtype as numpy.float64.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">HyperSpy signal</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.complex_signal.ComplexSignal_mixin.change_dtype">
<code class="descname">change_dtype</code><span class="sig-paren">(</span><em>dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal.ComplexSignal_mixin.change_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the data type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtype</strong> (<em>str</em><em> or </em><a class="reference internal" href="hyperspy.io_plugins.html#hyperspy.io_plugins.digital_micrograph.ImageObject.dtype" title="hyperspy.io_plugins.digital_micrograph.ImageObject.dtype"><em>dtype</em></a>) &#8211; Typecode or data-type to which the array is cast. For complex signals only other
complex dtypes are allowed. If real valued properties are required use <cite>real</cite>,
<cite>imag</cite>, <cite>amplitude</cite> and <cite>phase</cite> instead.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hyperspy._signals.complex_signal.ComplexSignal_mixin.imag">
<code class="descname">imag</code><a class="headerlink" href="#hyperspy._signals.complex_signal.ComplexSignal_mixin.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Get/set imaginary part of the data. Returns an
appropriate HyperSpy signal.</p>
</dd></dl>

<dl class="attribute">
<dt id="hyperspy._signals.complex_signal.ComplexSignal_mixin.phase">
<code class="descname">phase</code><a class="headerlink" href="#hyperspy._signals.complex_signal.ComplexSignal_mixin.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Get/set the phase of the data. Returns an appropriate
HyperSpy signal.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.complex_signal.ComplexSignal_mixin.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>navigator='auto'</em>, <em>axes_manager=None</em>, <em>representation='cartesian'</em>, <em>same_axes=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal.ComplexSignal_mixin.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the signal at the current coordinates.</p>
<p>For multidimensional datasets an optional figure,
the &#8220;navigator&#8221;, with a cursor to navigate that data is
raised. In any case it is possible to navigate the data using
the sliders. Currently only signals with signal_dimension equal to
0, 1 and 2 can be plotted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>navigator</strong> (<em>{&quot;auto&quot;</em><em>, </em><em>None</em><em>, </em><em>&quot;slider&quot;</em><em>, </em><em>&quot;spectrum&quot;</em><em>, </em><em>Signal}</em>) &#8211; If &#8220;auto&#8221;, if navigation_dimension &gt; 0, a navigator is
provided to explore the data.
If navigation_dimension is 1 and the signal is an image
the navigator is a spectrum obtained by integrating
over the signal axes (the image).
If navigation_dimension is 1 and the signal is a spectrum
the navigator is an image obtained by stacking horizontally
all the spectra in the dataset.
If navigation_dimension is &gt; 1, the navigator is an image
obtained by integrating the data over the signal axes.
Additionaly, if navigation_dimension &gt; 2 a window
with one slider per axis is raised to navigate the data.
For example,
if the dataset consists of 3 navigation axes X, Y, Z and one
signal axis, E, the default navigator will be an image
obtained by integrating the data over E at the current Z
index and a window with sliders for the X, Y and Z axes
will be raised. Notice that changing the Z-axis index
changes the navigator in this case.
If &#8220;slider&#8221; and the navigation dimension &gt; 0 a window
with one slider per axis is raised to navigate the data.
If &#8220;spectrum&#8221; and navigation_dimension &gt; 0 the navigator
is always a spectrum obtained by integrating the data
over all other axes.
If None, no navigator will be provided.
Alternatively a Signal instance can be provided. The signal
dimension must be 1 (for a spectrum navigator) or 2 (for a
image navigator) and navigation_shape must be 0 (for a static
navigator) or navigation_shape + signal_shape must be equal
to the navigator_shape of the current object (for a dynamic
navigator).
If the signal dtype is RGB or RGBA this parameters has no
effect and is always &#8220;slider&#8221;.</li>
<li><strong>axes_manager</strong> (<em>{None</em><em>, </em><em>axes_manager}</em>) &#8211; If None <cite>axes_manager</cite> is used.</li>
<li><strong>plot_markers</strong> (<em>bool</em><em>, </em><em>default True</em>) &#8211; Plot markers added using s.add_marker(marker, permanent=True).
Note, a large number of markers might lead to very slow plotting.</li>
<li><strong>representation</strong> (<em>{'cartesian'</em><em> or </em><em>'polar'}</em>) &#8211; Determines if the real and imaginary part of the complex data is plotted (&#8216;cartesian&#8217;,
default), or if the amplitude and phase should be used (&#8216;polar&#8217;).</li>
<li><strong>same_axes</strong> (<em>bool</em><em>, </em><em>default True</em>) &#8211; If True (default) plot the real and
imaginary parts (or amplitude and phase) in the same figure if
the signal is one-dimensional.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs, optional</dt>
<dd>Additional key word arguments passed to matplotlib.imshow()</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="hyperspy._signals.complex_signal.ComplexSignal_mixin.real">
<code class="descname">real</code><a class="headerlink" href="#hyperspy._signals.complex_signal.ComplexSignal_mixin.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Get/set the real part of the data. Returns an
appropriate HyperSpy signal.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.complex_signal.ComplexSignal_mixin.unwrapped_phase">
<code class="descname">unwrapped_phase</code><span class="sig-paren">(</span><em>wrap_around=False</em>, <em>seed=None</em>, <em>show_progressbar=None</em>, <em>parallel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal.ComplexSignal_mixin.unwrapped_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unwrapped phase as an appropriate HyperSpy signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>wrap_around</strong> (<em>bool</em><em> or </em><em>sequence of bool</em><em>, </em><em>optional</em>) &#8211; When an element of the sequence is  <cite>True</cite>, the unwrapping process
will regard the edges along the corresponding axis of the image to be
connected and use this connectivity to guide the phase unwrapping
process. If only a single boolean is given, it will apply to all axes.
Wrap around is not supported for 1D arrays.</li>
<li><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) &#8211; Unwrapping 2D or 3D images uses random initialization. This sets the
seed of the PRNG to achieve deterministic behavior.</li>
<li><strong>show_progressbar</strong> (<em>None</em><em> or </em><em>bool</em>) &#8211; If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</li>
<li><strong>parallel</strong> (<em>{Bool</em><em>, </em><em>None</em><em>, </em><em>int}</em>) &#8211; Perform the operation parallely</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>phase_image</strong> &#8211; Unwrapped phase.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="xref py py-class docutils literal"><span class="pre">BaseSignal</span></code> subclass</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Uses the <code class="xref py py-func docutils literal"><span class="pre">unwrap_phase()</span></code> function from <cite>skimage</cite>.
The algorithm is based on Miguel Arevallilo Herraez, David R. Burton, Michael J. Lalor,
and Munther A. Gdeisat, “Fast two-dimensional phase-unwrapping algorithm based on sorting
by reliability following a noncontinuous path”, Journal Applied Optics,
Vol. 41, No. 35, pp. 7437, 2002</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.complex_signal.LazyComplexSignal">
<em class="property">class </em><code class="descclassname">hyperspy._signals.complex_signal.</code><code class="descname">LazyComplexSignal</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal.LazyComplexSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.complex_signal.ComplexSignal" title="hyperspy._signals.complex_signal.ComplexSignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.complex_signal.ComplexSignal</span></code></a>, <a class="reference internal" href="#hyperspy._signals.lazy.LazySignal" title="hyperspy._signals.lazy.LazySignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.lazy.LazySignal</span></code></a></p>
<dl class="method">
<dt id="hyperspy._signals.complex_signal.LazyComplexSignal.angle">
<code class="descname">angle</code><span class="sig-paren">(</span><em>deg=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal.LazyComplexSignal.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle (also known as phase or argument). If the data is real, the angle is 0
for positive values and 2$pi$ for negative values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deg</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; Return angle in degrees if True, radians if False (default).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>angle</strong> &#8211; The counterclockwise angle from the positive real axis on the complex plane,
with dtype as numpy.float64.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">HyperSpy signal</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hyperspy._signals.complex_signal.format_title">
<code class="descclassname">hyperspy._signals.complex_signal.</code><code class="descname">format_title</code><span class="sig-paren">(</span><em>thing</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal.format_title" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.complex_signal1d">
<span id="hyperspy-signals-complex-signal1d-module"></span><h2>hyperspy._signals.complex_signal1d module<a class="headerlink" href="#module-hyperspy._signals.complex_signal1d" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.complex_signal1d.ComplexSignal1D">
<em class="property">class </em><code class="descclassname">hyperspy._signals.complex_signal1d.</code><code class="descname">ComplexSignal1D</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal1d.ComplexSignal1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.complex_signal.ComplexSignal" title="hyperspy._signals.complex_signal.ComplexSignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.complex_signal.ComplexSignal</span></code></a>, <a class="reference internal" href="#hyperspy._signals.common_signal1d.CommonSignal1D" title="hyperspy._signals.common_signal1d.CommonSignal1D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.common_signal1d.CommonSignal1D</span></code></a></p>
<p>BaseSignal subclass for complex 1-dimensional data.</p>
</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.complex_signal1d.LazyComplexSignal1D">
<em class="property">class </em><code class="descclassname">hyperspy._signals.complex_signal1d.</code><code class="descname">LazyComplexSignal1D</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal1d.LazyComplexSignal1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.complex_signal1d.ComplexSignal1D" title="hyperspy._signals.complex_signal1d.ComplexSignal1D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.complex_signal1d.ComplexSignal1D</span></code></a>, <a class="reference internal" href="#hyperspy._signals.complex_signal.LazyComplexSignal" title="hyperspy._signals.complex_signal.LazyComplexSignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.complex_signal.LazyComplexSignal</span></code></a></p>
<p>BaseSignal subclass for lazy complex 1-dimensional data.</p>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.complex_signal2d">
<span id="hyperspy-signals-complex-signal2d-module"></span><h2>hyperspy._signals.complex_signal2d module<a class="headerlink" href="#module-hyperspy._signals.complex_signal2d" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.complex_signal2d.Complex2Dmixin">
<em class="property">class </em><code class="descclassname">hyperspy._signals.complex_signal2d.</code><code class="descname">Complex2Dmixin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal2d.Complex2Dmixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>BaseSignal subclass for complex 2-dimensional data.</p>
<dl class="method">
<dt id="hyperspy._signals.complex_signal2d.Complex2Dmixin.add_phase_ramp">
<code class="descname">add_phase_ramp</code><span class="sig-paren">(</span><em>ramp_x</em>, <em>ramp_y</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal2d.Complex2Dmixin.add_phase_ramp" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a linear phase ramp to the wave.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ramp_x</strong> (<em>float</em>) &#8211; Slope of the ramp in x-direction.</li>
<li><strong>ramp_y</strong> (<em>float</em>) &#8211; Slope of the ramp in y-direction.</li>
<li><strong>offset</strong> (<em>float</em><em>, </em><em>optional</em>) &#8211; Offset of the ramp at the fulcrum.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The fulcrum of the linear ramp is at the origin and the slopes are
given in units of the axis with the according scale taken into
account. Both are available via the <cite>axes_manager</cite> of the signal.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.complex_signal2d.Complex2Dmixin.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>colorbar=True</em>, <em>scalebar=True</em>, <em>scalebar_color='white'</em>, <em>axes_ticks=None</em>, <em>saturated_pixels=0</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>no_nans=False</em>, <em>centre_colormap='auto'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal2d.Complex2Dmixin.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the signal at the current coordinates.</p>
<p>For multidimensional datasets an optional figure,
the &#8220;navigator&#8221;, with a cursor to navigate that data is
raised. In any case it is possible to navigate the data using
the sliders. Currently only signals with signal_dimension equal to
0, 1 and 2 can be plotted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>navigator</strong> (<em>{&quot;auto&quot;</em><em>, </em><em>None</em><em>, </em><em>&quot;slider&quot;</em><em>, </em><em>&quot;spectrum&quot;</em><em>, </em><em>Signal}</em>) &#8211; If &#8220;auto&#8221;, if navigation_dimension &gt; 0, a navigator is
provided to explore the data.
If navigation_dimension is 1 and the signal is an image
the navigator is a spectrum obtained by integrating
over the signal axes (the image).
If navigation_dimension is 1 and the signal is a spectrum
the navigator is an image obtained by stacking horizontally
all the spectra in the dataset.
If navigation_dimension is &gt; 1, the navigator is an image
obtained by integrating the data over the signal axes.
Additionaly, if navigation_dimension &gt; 2 a window
with one slider per axis is raised to navigate the data.
For example,
if the dataset consists of 3 navigation axes X, Y, Z and one
signal axis, E, the default navigator will be an image
obtained by integrating the data over E at the current Z
index and a window with sliders for the X, Y and Z axes
will be raised. Notice that changing the Z-axis index
changes the navigator in this case.
If &#8220;slider&#8221; and the navigation dimension &gt; 0 a window
with one slider per axis is raised to navigate the data.
If &#8220;spectrum&#8221; and navigation_dimension &gt; 0 the navigator
is always a spectrum obtained by integrating the data
over all other axes.
If None, no navigator will be provided.
Alternatively a Signal instance can be provided. The signal
dimension must be 1 (for a spectrum navigator) or 2 (for a
image navigator) and navigation_shape must be 0 (for a static
navigator) or navigation_shape + signal_shape must be equal
to the navigator_shape of the current object (for a dynamic
navigator).
If the signal dtype is RGB or RGBA this parameters has no
effect and is always &#8220;slider&#8221;.</li>
<li><strong>axes_manager</strong> (<em>{None</em><em>, </em><em>axes_manager}</em>) &#8211; If None <cite>axes_manager</cite> is used.</li>
<li><strong>plot_markers</strong> (<em>bool</em><em>, </em><em>default True</em>) &#8211; Plot markers added using s.add_marker(marker, permanent=True).
Note, a large number of markers might lead to very slow plotting.</li>
<li><strong>colorbar</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; If true, a colorbar is plotted for non-RGB images.</li>
<li><strong>scalebar</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; If True and the units and scale of the x and y axes are the same a
scale bar is plotted.</li>
<li><strong>scalebar_color</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; A valid MPL color string; will be used as the scalebar color.</li>
<li><strong>axes_ticks</strong> (<em>{None</em><em>, </em><em>bool}</em><em>, </em><em>optional</em>) &#8211; If True, plot the axes ticks. If None axes_ticks are only
plotted when the scale bar is not plotted. If False the axes ticks
are never plotted.</li>
<li><strong>saturated_pixels</strong> (<em>scalar</em>) &#8211; The percentage of pixels that are left out of the bounds.
For example, the low and high bounds of a value of 1 are the 0.5%
and 99.5% percentiles. It must be in the [0, 100] range.</li>
<li><strong>vmax</strong> (<a class="reference internal" href="hyperspy.drawing.html#hyperspy.drawing.image.ImagePlot.vmin" title="hyperspy.drawing.image.ImagePlot.vmin"><em>vmin</em></a><em>,</em>) &#8211; <cite>vmin</cite> and <cite>vmax</cite> are used to normalize luminance data.</li>
<li><strong>no_nans</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; If True, set nans to zero for plotting.</li>
<li><strong>centre_colormap</strong> (<em>{&quot;auto&quot;</em><em>, </em><em>True</em><em>, </em><em>False}</em>) &#8211; If True the centre of the color scheme is set to zero. This is
specially useful when using diverging color schemes. If &#8220;auto&#8221;
(default), diverging color schemes are automatically centred.</li>
<li><strong>representation</strong> (<em>{'cartesian'</em><em> or </em><em>'polar'}</em>) &#8211; Determines if the real and imaginary part of the complex data is plotted (&#8216;cartesian&#8217;,
default), or if the amplitude and phase should be used (&#8216;polar&#8217;).</li>
<li><strong>same_axes</strong> (<em>bool</em><em>, </em><em>default True</em>) &#8211; If True (default) plot the real and
imaginary parts (or amplitude and phase) in the same figure if
the signal is one-dimensional.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt><a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs, optional</dt>
<dd>Additional key word arguments passed to matplotlib.imshow()</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.complex_signal2d.ComplexSignal2D">
<em class="property">class </em><code class="descclassname">hyperspy._signals.complex_signal2d.</code><code class="descname">ComplexSignal2D</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal2d.ComplexSignal2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.complex_signal2d.Complex2Dmixin" title="hyperspy._signals.complex_signal2d.Complex2Dmixin"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.complex_signal2d.Complex2Dmixin</span></code></a>, <a class="reference internal" href="#hyperspy._signals.complex_signal.ComplexSignal" title="hyperspy._signals.complex_signal.ComplexSignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.complex_signal.ComplexSignal</span></code></a>, <a class="reference internal" href="#hyperspy._signals.common_signal2d.CommonSignal2D" title="hyperspy._signals.common_signal2d.CommonSignal2D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.common_signal2d.CommonSignal2D</span></code></a></p>
<p>BaseSignal subclass for complex 2-dimensional data.</p>
</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.complex_signal2d.LazyComplexSignal2D">
<em class="property">class </em><code class="descclassname">hyperspy._signals.complex_signal2d.</code><code class="descname">LazyComplexSignal2D</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.complex_signal2d.LazyComplexSignal2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.complex_signal2d.ComplexSignal2D" title="hyperspy._signals.complex_signal2d.ComplexSignal2D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.complex_signal2d.ComplexSignal2D</span></code></a>, <a class="reference internal" href="#hyperspy._signals.complex_signal.LazyComplexSignal" title="hyperspy._signals.complex_signal.LazyComplexSignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.complex_signal.LazyComplexSignal</span></code></a></p>
<p>BaseSignal subclass for lazy complex 2-dimensional data.</p>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.dielectric_function">
<span id="hyperspy-signals-dielectric-function-module"></span><h2>hyperspy._signals.dielectric_function module<a class="headerlink" href="#module-hyperspy._signals.dielectric_function" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.dielectric_function.DielectricFunction">
<em class="property">class </em><code class="descclassname">hyperspy._signals.dielectric_function.</code><code class="descname">DielectricFunction</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.dielectric_function.DielectricFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.dielectric_function.DielectricFunction_mixin" title="hyperspy._signals.dielectric_function.DielectricFunction_mixin"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.dielectric_function.DielectricFunction_mixin</span></code></a>, <a class="reference internal" href="#hyperspy._signals.complex_signal1d.ComplexSignal1D" title="hyperspy._signals.complex_signal1d.ComplexSignal1D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.complex_signal1d.ComplexSignal1D</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.dielectric_function.DielectricFunction_mixin">
<em class="property">class </em><code class="descclassname">hyperspy._signals.dielectric_function.</code><code class="descname">DielectricFunction_mixin</code><a class="headerlink" href="#hyperspy._signals.dielectric_function.DielectricFunction_mixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="hyperspy._signals.dielectric_function.DielectricFunction_mixin.get_electron_energy_loss_spectrum">
<code class="descname">get_electron_energy_loss_spectrum</code><span class="sig-paren">(</span><em>zlp</em>, <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.dielectric_function.DielectricFunction_mixin.get_electron_energy_loss_spectrum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy._signals.dielectric_function.DielectricFunction_mixin.get_number_of_effective_electrons">
<code class="descname">get_number_of_effective_electrons</code><span class="sig-paren">(</span><em>nat</em>, <em>cumulative=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.dielectric_function.DielectricFunction_mixin.get_number_of_effective_electrons" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Compute the number of effective electrons using the Bethe f-sum</dt>
<dd><p class="first">rule.</p>
<p class="last">The Bethe f-sum rule gives rise to two definitions of the effective
number (see <a class="reference internal" href="../user_guide/bibliography.html#egerton2011" id="id5">[Egerton2011]</a>):
$n_{mathrm{eff}}left(-Imleft(epsilon^{-1}</p>
</dd>
</dl>
<p>ight)
ight)$ that</p>
<blockquote>
<div>we&#8217;ll call neff1 and
$n_{mathrm{eff}}left(epsilon_{2}</div></blockquote>
<dl class="docutils">
<dt>ight)$ that we&#8217;ll call neff2. This</dt>
<dd><p class="first">method computes both.</p>
<dl class="docutils">
<dt>nat: float</dt>
<dd>Number of atoms (or molecules) per unit volume of the
sample.</dd>
<dt>cumulative <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If False calculate the number of effective electrons up to the
higher energy-loss of the spectrum. If True, calculate the
number of effective electrons as a function of the energy-loss up
to the higher energy-loss of the spectrum. <em>True is only supported
by SciPy newer than 0.13.2</em>.</dd>
</dl>
<dl class="docutils">
<dt>neff1, neff2: Signal1D</dt>
<dd>Signal1D instances containing neff1 and neff2. The signal and
navigation dimensions are the same as the current signal if
<cite>cumulative</cite> is True, otherwise the signal dimension is 0
and the navigation dimension is the same as the current
signal.</dd>
</dl>
<table class="docutils citation" frame="void" id="egerton2011" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Egerton2011]</td><td>Ray Egerton, &#8220;Electron Energy-Loss</td></tr>
</tbody>
</table>
<p class="last">Spectroscopy in the Electron Microscope&#8221;, Springer-Verlag, 2011.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.dielectric_function.LazyDielectricFunction">
<em class="property">class </em><code class="descclassname">hyperspy._signals.dielectric_function.</code><code class="descname">LazyDielectricFunction</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.dielectric_function.LazyDielectricFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.dielectric_function.DielectricFunction" title="hyperspy._signals.dielectric_function.DielectricFunction"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.dielectric_function.DielectricFunction</span></code></a>, <a class="reference internal" href="#hyperspy._signals.complex_signal1d.LazyComplexSignal1D" title="hyperspy._signals.complex_signal1d.LazyComplexSignal1D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.complex_signal1d.LazyComplexSignal1D</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.eds">
<span id="hyperspy-signals-eds-module"></span><h2>hyperspy._signals.eds module<a class="headerlink" href="#module-hyperspy._signals.eds" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.eds.EDSSpectrum">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eds.</code><code class="descname">EDSSpectrum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDSSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin" title="hyperspy._signals.eds.EDS_mixin"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds.EDS_mixin</span></code></a>, <a class="reference internal" href="#hyperspy._signals.signal1d.Signal1D" title="hyperspy._signals.signal1d.Signal1D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.signal1d.Signal1D</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.eds.EDS_mixin">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eds.</code><code class="descname">EDS_mixin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.add_elements">
<code class="descname">add_elements</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.add_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Add elements and the corresponding X-ray lines.</p>
<p>The list of elements is stored in <cite>metadata.Sample.elements</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>elements</strong> (<em>list of strings</em>) &#8211; The symbol of the elements.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Sample</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_elements</span><span class="p">([</span><span class="s1">&#39;Ar&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Sample</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
<span class="go">[&#39;Al&#39; &#39;C&#39; &#39;Cu&#39; &#39;Mn&#39; &#39;Zr&#39;]</span>
<span class="go">[&#39;Al&#39;, &#39;Ar&#39;, &#39;C&#39;, &#39;Cu&#39;, &#39;Mn&#39;, &#39;Zr&#39;]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.set_elements" title="hyperspy._signals.eds.EDS_mixin.set_elements"><code class="xref py py-meth docutils literal"><span class="pre">set_elements()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.add_lines" title="hyperspy._signals.eds.EDS_mixin.add_lines"><code class="xref py py-meth docutils literal"><span class="pre">add_lines()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.set_lines" title="hyperspy._signals.eds.EDS_mixin.set_lines"><code class="xref py py-meth docutils literal"><span class="pre">set_lines()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.add_lines">
<code class="descname">add_lines</code><span class="sig-paren">(</span><em>lines=()</em>, <em>only_one=True</em>, <em>only_lines=('a'</em>, <em>)</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.add_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Add X-rays lines to the internal list.</p>
<p>Although most functions do not require an internal list of
X-ray lines because they can be calculated from the internal
list of elements, ocassionally it might be useful to customize the
X-ray lines to be use by all functions by default using this method.
The list of X-ray lines is stored in
<cite>metadata.Sample.xray_lines</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lines</strong> (<em>list of strings</em>) &#8211; A list of valid element X-ray lines to add e.g. Fe_Kb.
Additionally, if <cite>metadata.Sample.elements</cite> is
defined, add the lines of those elements that where not
given in this list. If the list is empty (default), and
<cite>metadata.Sample.elements</cite> is
defined, add the lines of all those elements.</li>
<li><strong>only_one</strong> (<em>bool</em>) &#8211; If False, add all the lines of each element in
<cite>metadata.Sample.elements</cite> that has not line
defined in lines. If True (default),
only add the line at the highest energy
above an overvoltage of 2 (&lt; beam energy / 2).</li>
<li><strong>only_lines</strong> (<em>{None</em><em>, </em><em>list of strings}</em>) &#8211; If not None, only the given lines will be added.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_lines</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Sample</span><span class="o">.</span><span class="n">xray_lines</span><span class="p">)</span>
<span class="go">[&#39;Al_Ka&#39;, &#39;C_Ka&#39;, &#39;Cu_La&#39;, &#39;Mn_La&#39;, &#39;Zr_La&#39;]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_microscope_parameters</span><span class="p">(</span><span class="n">beam_energy</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_lines</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Sample</span><span class="o">.</span><span class="n">xray_lines</span><span class="p">)</span>
<span class="go">[&#39;Al_Ka&#39;, &#39;C_Ka&#39;, &#39;Cu_Ka&#39;, &#39;Mn_Ka&#39;, &#39;Zr_La&#39;]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_lines</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Sample</span><span class="o">.</span><span class="n">xray_lines</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_lines</span><span class="p">([</span><span class="s1">&#39;Cu_Ka&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Sample</span><span class="o">.</span><span class="n">xray_lines</span><span class="p">)</span>
<span class="go">[&#39;Al_Ka&#39;, &#39;C_Ka&#39;, &#39;Cu_La&#39;, &#39;Mn_La&#39;, &#39;Zr_La&#39;]</span>
<span class="go">[&#39;Al_Ka&#39;, &#39;C_Ka&#39;, &#39;Cu_Ka&#39;, &#39;Cu_La&#39;, &#39;Mn_La&#39;, &#39;Zr_La&#39;]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.set_lines" title="hyperspy._signals.eds.EDS_mixin.set_lines"><code class="xref py py-meth docutils literal"><span class="pre">set_lines()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.add_elements" title="hyperspy._signals.eds.EDS_mixin.add_elements"><code class="xref py py-meth docutils literal"><span class="pre">add_elements()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.set_elements" title="hyperspy._signals.eds.EDS_mixin.set_elements"><code class="xref py py-meth docutils literal"><span class="pre">set_elements()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.add_xray_lines_markers">
<code class="descname">add_xray_lines_markers</code><span class="sig-paren">(</span><em>xray_lines</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.add_xray_lines_markers" title="Permalink to this definition">¶</a></dt>
<dd><p>Add marker on a spec.plot() with the name of the selected X-ray
lines</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>xray_lines</strong> (<em>list of string</em>) &#8211; A valid list of X-ray lines</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.estimate_background_windows">
<code class="descname">estimate_background_windows</code><span class="sig-paren">(</span><em>line_width=[2, 2], windows_width=1, xray_lines=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.estimate_background_windows" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate two windows around each X-ray line containing only the
background.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>line_width</strong> (<em>list of two floats</em>) &#8211; The position of the two windows around the X-ray line is given by
the <cite>line_width</cite> (left and right) times the calculated FWHM of the
line.</li>
<li><strong>windows_width</strong> (<em>float</em>) &#8211; The width of the windows is is the <cite>windows_width</cite> times the
calculated FWHM of the line.</li>
<li><strong>xray_lines</strong> (<em>None</em><em> or </em><em>list of string</em>) &#8211; If None, use <cite>metadata.Sample.elements.xray_lines</cite>. Else,
provide an iterable containing a list of valid X-ray lines
symbols.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>windows_position</strong> &#8211; The position of the windows in energy. Each line corresponds to a
X-ray line. In a line, the two first values correspond to the
limits of the left window and the two last values correspond to
the limits of the right window.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2D array of float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_TEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_lines</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bw</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">estimate_background_windows</span><span class="p">(</span><span class="n">line_width</span><span class="o">=</span><span class="p">[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">background_windows</span><span class="o">=</span><span class="n">bw</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_lines_intensity</span><span class="p">(</span><span class="n">background_windows</span><span class="o">=</span><span class="n">bw</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Fe_Ka at 6.4039 keV : Intensity = 2754.00</span>
<span class="go">Pt_La at 9.4421 keV : Intensity = 15090.00</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.plot" title="hyperspy._signals.eds.EDS_mixin.plot"><code class="xref py py-meth docutils literal"><span class="pre">plot()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.get_lines_intensity" title="hyperspy._signals.eds.EDS_mixin.get_lines_intensity"><code class="xref py py-meth docutils literal"><span class="pre">get_lines_intensity()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.estimate_integration_windows">
<code class="descname">estimate_integration_windows</code><span class="sig-paren">(</span><em>windows_width=2.0</em>, <em>xray_lines=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.estimate_integration_windows" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate a window of integration for each X-ray line.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>windows_width</strong> (<em>float</em>) &#8211; The width of the integration windows is the &#8216;windows_width&#8217; times
the calculated FWHM of the line.</li>
<li><strong>xray_lines</strong> (<em>None</em><em> or </em><em>list of string</em>) &#8211; If None, use &#8216;metadata.Sample.elements.xray_lines&#8217;. Else,
provide an iterable containing a list of valid X-ray lines
symbols.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>integration_windows</strong> &#8211; The positions of the windows in energy. Each row corresponds to a
X-ray line. Each row contains the left and right value of the
window.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2D array of float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_TEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_lines</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iw</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">estimate_integration_windows</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">integration_windows</span><span class="o">=</span><span class="n">iw</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_lines_intensity</span><span class="p">(</span><span class="n">integration_windows</span><span class="o">=</span><span class="n">iw</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Fe_Ka at 6.4039 keV : Intensity = 3710.00</span>
<span class="go">Pt_La at 9.4421 keV : Intensity = 15872.00</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.plot" title="hyperspy._signals.eds.EDS_mixin.plot"><code class="xref py py-meth docutils literal"><span class="pre">plot()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.get_lines_intensity" title="hyperspy._signals.eds.EDS_mixin.get_lines_intensity"><code class="xref py py-meth docutils literal"><span class="pre">get_lines_intensity()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.get_lines_intensity">
<code class="descname">get_lines_intensity</code><span class="sig-paren">(</span><em>xray_lines=None</em>, <em>integration_windows=2.0</em>, <em>background_windows=None</em>, <em>plot_result=False</em>, <em>only_one=True</em>, <em>only_lines=('a'</em>, <em>)</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.get_lines_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intensity map of selected Xray lines.</p>
<p>The intensities, the number of X-ray counts, are computed by
suming the spectrum over the
different X-ray lines. The sum window width
is calculated from the energy resolution of the detector
as defined in &#8216;energy_resolution_MnKa&#8217; of the metadata.
Backgrounds average in provided windows can be subtracted from the
intensities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xray_lines</strong> (<em>{None</em><em>, </em><em>&quot;best&quot;</em><em>, </em><em>list of string}</em>) &#8211; If None,
if <cite>metadata.Sample.elements.xray_lines</cite> contains a
list of lines use those.
If <cite>metadata.Sample.elements.xray_lines</cite> is undefined
or empty but <cite>metadata.Sample.elements</cite> is defined,
use the same syntax as <cite>add_line</cite> to select a subset of lines
for the operation.
Alternatively, provide an iterable containing
a list of valid X-ray lines symbols.</li>
<li><strong>integration_windows</strong> (<em>Float</em><em> or </em><em>array</em>) &#8211; If float, the width of the integration windows is the
&#8216;integration_windows_width&#8217; times the calculated FWHM of the line.
Else provide an array for which each row corresponds to a X-ray
line. Each row contains the left and right value of the window.</li>
<li><strong>background_windows</strong> (<em>None</em><em> or </em><em>2D array of float</em>) &#8211; If None, no background subtraction. Else, the backgrounds average
in the windows are subtracted from the return intensities.
&#8216;background_windows&#8217; provides the position of the windows in
energy. Each line corresponds to a X-ray line. In a line, the two
first values correspond to the limits of the left window and the
two last values correspond to the limits of the right window.</li>
<li><strong>plot_result</strong> (<em>bool</em>) &#8211; If True, plot the calculated line intensities. If the current
object is a single spectrum it prints the result instead.</li>
<li><strong>only_one</strong> (<em>bool</em>) &#8211; If False, use all the lines of each element in the data spectral
range. If True use only the line at the highest energy
above an overvoltage of 2 (&lt; beam energy / 2).</li>
<li><strong>only_lines</strong> (<em>{None</em><em>, </em><em>list of strings}</em>) &#8211; If not None, use only the given lines.</li>
<li><strong>kwargs</strong> &#8211; The extra keyword arguments for plotting. See
<cite>utils.plot.plot_signals</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>intensities</strong> &#8211; A list containing the intensities as BaseSignal subclasses.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_lines_intensity</span><span class="p">([</span><span class="s1">&#39;Mn_Ka&#39;</span><span class="p">],</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Mn_La at 0.63316 keV : Intensity = 96700.00</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="s1">&#39;Mn_Ka&#39;</span><span class="p">],</span> <span class="n">integration_windows</span><span class="o">=</span><span class="mf">2.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_lines_intensity</span><span class="p">([</span><span class="s1">&#39;Mn_Ka&#39;</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                      <span class="n">integration_windows</span><span class="o">=</span><span class="mf">2.1</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Mn_Ka at 5.8987 keV : Intensity = 53597.00</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_elements</span><span class="p">([</span><span class="s1">&#39;Mn&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_lines</span><span class="p">([</span><span class="s1">&#39;Mn_Ka&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bw</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">estimate_background_windows</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">background_windows</span><span class="o">=</span><span class="n">bw</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_lines_intensity</span><span class="p">(</span><span class="n">background_windows</span><span class="o">=</span><span class="n">bw</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Mn_Ka at 5.8987 keV : Intensity = 46716.00</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.set_elements" title="hyperspy._signals.eds.EDS_mixin.set_elements"><code class="xref py py-meth docutils literal"><span class="pre">set_elements()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.add_elements" title="hyperspy._signals.eds.EDS_mixin.add_elements"><code class="xref py py-meth docutils literal"><span class="pre">add_elements()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.estimate_background_windows" title="hyperspy._signals.eds.EDS_mixin.estimate_background_windows"><code class="xref py py-meth docutils literal"><span class="pre">estimate_background_windows()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.plot" title="hyperspy._signals.eds.EDS_mixin.plot"><code class="xref py py-meth docutils literal"><span class="pre">plot()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.get_take_off_angle">
<code class="descname">get_take_off_angle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.get_take_off_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the take-off-angle (TOA).</p>
<p>TOA is the angle with which the X-rays leave the surface towards
the detector. Parameters are read in &#8216;SEM.Stage.tilt_alpha&#8217;,
&#8216;Acquisition_instrument.SEM.Detector.EDS.azimuth_angle&#8217; and
&#8216;SEM.Detector.EDS.elevation_angle&#8217; in &#8216;metadata&#8217;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>take_off_angle</strong> &#8211; in Degree</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_take_off_angle</span><span class="p">()</span>
<span class="go">37.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_microscope_parameters</span><span class="p">(</span><span class="n">tilt_stage</span><span class="o">=</span><span class="mf">20.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_take_off_angle</span><span class="p">()</span>
<span class="go">57.0</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">hs.eds.take_off_angle()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Defined by M. Schaffer et al., Ultramicroscopy 107(8), pp 587-597
(2007)</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>xray_lines=False</em>, <em>only_lines=('a'</em>, <em>'b')</em>, <em>only_one=False</em>, <em>background_windows=None</em>, <em>integration_windows=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the EDS spectrum. The following markers can be added</p>
<ul class="simple">
<li>The position of the X-ray lines and their names.</li>
<li>The background windows associated with each X-ray lines. A black line</li>
</ul>
<p>links the left and right window with the average value in each window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>xray_lines</strong> (<em>{False</em><em>, </em><em>True</em><em>, </em><em>'from_elements'</em><em>, </em><em>list of string}</em>) &#8211; If not False, indicate the position and the name of the X-ray
lines.
If True, if <cite>metadata.Sample.elements.xray_lines</cite> contains a
list of lines use those. If <cite>metadata.Sample.elements.xray_lines</cite>
is undefined or empty or if xray_lines equals &#8216;from_elements&#8217; and
<cite>metadata.Sample.elements</cite> is defined, use the same syntax as
<cite>add_line</cite> to select a subset of lines for the operation.
Alternatively, provide an iterable containing a list of valid X-ray
lines symbols.</li>
<li><strong>only_lines</strong> (<em>None</em><em> or </em><em>list of strings</em>) &#8211; If not None, use only the given lines (eg. (&#8216;a&#8217;,&#8217;Kb&#8217;)).
If None, use all lines.</li>
<li><strong>only_one</strong> (<em>bool</em>) &#8211; If False, use all the lines of each element in the data spectral
range. If True use only the line at the highest energy
above an overvoltage of 2 (&lt; beam energy / 2).</li>
<li><strong>background_windows</strong> (<em>None</em><em> or </em><em>2D array of float</em>) &#8211; If not None, add markers at the position of the windows in energy.
Each line corresponds to a X-ray lines. In a line, the two first
value corresponds to the limit of the left window and the two
last values corresponds to the limit of the right window.</li>
<li><strong>integration_windows</strong> (<em>None</em><em> or </em><em>'auto'</em><em> or </em><em>float</em><em> or </em><em>2D array of float</em>) &#8211; If not None, add markers at the position of the integration
windows.
If &#8216;auto&#8217; (or float), the width of the integration windows is 2.0
(or float) times the calculated FWHM of the line. see
&#8216;estimate_integration_windows&#8217;.
Else provide an array for which each row corresponds to a X-ray
line. Each row contains the left and right value of the window.</li>
<li><strong>kwargs</strong> &#8211; The extra keyword arguments for plot()</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_TEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_lines</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bw</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">estimate_background_windows</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">background_windows</span><span class="o">=</span><span class="n">bw</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="s1">&#39;Mn_Ka&#39;</span><span class="p">],</span> <span class="n">integration_windows</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_TEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_lines</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bw</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">estimate_background_windows</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">background_windows</span><span class="o">=</span><span class="n">bw</span><span class="p">,</span> <span class="n">integration_windows</span><span class="o">=</span><span class="mf">2.1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.set_elements" title="hyperspy._signals.eds.EDS_mixin.set_elements"><code class="xref py py-meth docutils literal"><span class="pre">set_elements()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.add_elements" title="hyperspy._signals.eds.EDS_mixin.add_elements"><code class="xref py py-meth docutils literal"><span class="pre">add_elements()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.estimate_integration_windows" title="hyperspy._signals.eds.EDS_mixin.estimate_integration_windows"><code class="xref py py-meth docutils literal"><span class="pre">estimate_integration_windows()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.get_lines_intensity" title="hyperspy._signals.eds.EDS_mixin.get_lines_intensity"><code class="xref py py-meth docutils literal"><span class="pre">get_lines_intensity()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.estimate_background_windows" title="hyperspy._signals.eds.EDS_mixin.estimate_background_windows"><code class="xref py py-meth docutils literal"><span class="pre">estimate_background_windows()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.rebin">
<code class="descname">rebin</code><span class="sig-paren">(</span><em>new_shape=None</em>, <em>scale=None</em>, <em>crop=True</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.rebin" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebin array.</p>
<p>Rebin the signal into a smaller or larger shape, based on linear
interpolation. Specify <strong>either</strong> new_shape or scale.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_shape</strong> (<em>a list of floats</em><em> or </em><em>integer</em><em>, </em><em>default None</em>) &#8211; For each dimension specify the new_shape. This will
then be converted into a scale.</li>
<li><strong>scale</strong> (<em>a list of floats</em><em> or </em><em>integer</em><em>, </em><em>default None</em>) &#8211; For each dimension specify the new:old pixel ratio, e.g. a ratio of 1
is no binning and a ratio of 2 means that each pixel in the new
spectrum is twice the size of the pixels in the old spectrum.
The length of the list should match the dimension of the numpy array.
<strong>*Note : Only one of scale or new_shape should be specified otherwise
the function will not run*</strong></li>
<li><strong>crop</strong> (<em>bool</em><em>, </em><em>default True</em>) &#8211; <p>When binning by a non-integer number of pixels it is likely that
the final row in each dimension contains less than the full quota to
fill one pixel.</p>
<p>e.g. 5*5 array binned by 2.1 will produce two rows containing 2.1
pixels and one row containing only 0.8 pixels worth. Selection of
crop=&#8217;True&#8217; or crop=&#8217;False&#8217; determines whether or not this
&#8216;black&#8217; line is cropped from the final binned array or not.</p>
<p><em>Please note that if crop=False is used, the final row in each
dimension may appear black, if a fractional number of pixels are left
over. It can be removed but has been left to preserve total counts
before and after binning.</em></p>
</li>
<li><strong>out</strong> (<em>{Signal</em><em>, </em><em>None}</em>) &#8211; If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Signal subclass</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">EDSTEMSpectrum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectrum</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
<span class="go">&lt;EDXTEMSpectrum, title: dimensions: (4, 4|10)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;Sum = &#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">data</span><span class="p">))))</span>
<span class="go">Sum = 164.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="go">&lt;EDSTEMSpectrum, title: dimensions (2, 2|2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sum = &#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">data</span><span class="p">))))</span>
<span class="go">Sum =  164.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.remove_xray_lines_markers">
<code class="descname">remove_xray_lines_markers</code><span class="sig-paren">(</span><em>xray_lines</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.remove_xray_lines_markers" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove marker previosuly added on a spec.plot() with the name of the
selected X-ray lines</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>xray_lines</strong> (<em>list of string</em>) &#8211; A valid list of X-ray lines to remove</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.set_elements">
<code class="descname">set_elements</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.set_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase all elements and set them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>elements</strong> (<em>list of strings</em>) &#8211; A list of chemical element symbols.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.add_elements" title="hyperspy._signals.eds.EDS_mixin.add_elements"><code class="xref py py-meth docutils literal"><span class="pre">add_elements()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.set_lines" title="hyperspy._signals.eds.EDS_mixin.set_lines"><code class="xref py py-meth docutils literal"><span class="pre">set_lines()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.add_lines" title="hyperspy._signals.eds.EDS_mixin.add_lines"><code class="xref py py-meth docutils literal"><span class="pre">add_lines()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Sample</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_elements</span><span class="p">([</span><span class="s1">&#39;Al&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Sample</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
<span class="go">[&#39;Al&#39; &#39;C&#39; &#39;Cu&#39; &#39;Mn&#39; &#39;Zr&#39;]</span>
<span class="go">[&#39;Al&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.set_lines">
<code class="descname">set_lines</code><span class="sig-paren">(</span><em>lines</em>, <em>only_one=True</em>, <em>only_lines=('a'</em>, <em>)</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.set_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase all Xrays lines and set them.</p>
<p>See add_lines for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lines</strong> (<em>list of strings</em>) &#8211; A list of valid element X-ray lines to add e.g. Fe_Kb.
Additionally, if <cite>metadata.Sample.elements</cite> is
defined, add the lines of those elements that where not
given in this list.</li>
<li><strong>only_one</strong> (<em>bool</em>) &#8211; If False, add all the lines of each element in
<cite>metadata.Sample.elements</cite> that has not line
defined in lines. If True (default),
only add the line at the highest energy
above an overvoltage of 2 (&lt; beam energy / 2).</li>
<li><strong>only_lines</strong> (<em>{None</em><em>, </em><em>list of strings}</em>) &#8211; If not None, only the given lines will be added.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_lines</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Sample</span><span class="o">.</span><span class="n">xray_lines</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_lines</span><span class="p">([</span><span class="s1">&#39;Cu_Ka&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Sample</span><span class="o">.</span><span class="n">xray_lines</span><span class="p">)</span>
<span class="go">[&#39;Al_Ka&#39;, &#39;C_Ka&#39;, &#39;Cu_La&#39;, &#39;Mn_La&#39;, &#39;Zr_La&#39;]</span>
<span class="go">[&#39;Al_Ka&#39;, &#39;C_Ka&#39;, &#39;Cu_Ka&#39;, &#39;Mn_La&#39;, &#39;Zr_La&#39;]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.add_lines" title="hyperspy._signals.eds.EDS_mixin.add_lines"><code class="xref py py-meth docutils literal"><span class="pre">add_lines()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.add_elements" title="hyperspy._signals.eds.EDS_mixin.add_elements"><code class="xref py py-meth docutils literal"><span class="pre">add_elements()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDS_mixin.set_elements" title="hyperspy._signals.eds.EDS_mixin.set_elements"><code class="xref py py-meth docutils literal"><span class="pre">set_elements()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDS_mixin.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDS_mixin.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum the data over the given axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>axis</strong> (<em>{int | string | axis | tuple | None}</em>) &#8211; Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</li>
<li><strong>out</strong> (<em>{Signal</em><em>, </em><em>None}</em>) &#8211; If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Signal</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">max()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">min()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">mean()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">std()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">var()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">indexmax()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">valuemax()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">amax()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.eds.LazyEDSSpectrum">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eds.</code><code class="descname">LazyEDSSpectrum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.LazyEDSSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum" title="hyperspy._signals.eds.EDSSpectrum"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds.EDSSpectrum</span></code></a>, <a class="reference internal" href="#hyperspy._signals.signal1d.LazySignal1D" title="hyperspy._signals.signal1d.LazySignal1D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.signal1d.LazySignal1D</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.eds_sem">
<span id="hyperspy-signals-eds-sem-module"></span><h2>hyperspy._signals.eds_sem module<a class="headerlink" href="#module-hyperspy._signals.eds_sem" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.eds_sem.EDSSEMParametersUI">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eds_sem.</code><code class="descname">EDSSEMParametersUI</code><span class="sig-paren">(</span><em>signal</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_sem.EDSSEMParametersUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hyperspy.html#hyperspy.signal.BaseSetMetadataItems" title="hyperspy.signal.BaseSetMetadataItems"><code class="xref py py-class docutils literal"><span class="pre">hyperspy.signal.BaseSetMetadataItems</span></code></a></p>
<dl class="method">
<dt id="hyperspy._signals.eds_sem.EDSSEMParametersUI.gui">
<code class="descname">gui</code><span class="sig-paren">(</span><em>display=True</em>, <em>toolkit=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_sem.EDSSEMParametersUI.gui" title="Permalink to this definition">¶</a></dt>
<dd><p>Display or return interactive GUI element if available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>display</strong> (<em>bool</em>) &#8211; If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</li>
<li><strong>toolkit</strong> (<em>str</em><em>, </em><em>iterable of strings</em><em> or </em><em>None</em>) &#8211; If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hyperspy._signals.eds_sem.EDSSEMParametersUI.mapping">
<code class="descname">mapping</code><em class="property"> = {'Acquisition_instrument.SEM.beam_energy': 'beam_energy', 'Acquisition_instrument.TEM.Stage.tilt_alpha': 'tilt_stage', 'Acquisition_instrument.SEM.Detector.EDS.live_time': 'live_time', 'Acquisition_instrument.SEM.Detector.EDS.azimuth_angle': 'azimuth_angle', 'Acquisition_instrument.SEM.Detector.EDS.elevation_angle': 'elevation_angle', 'Acquisition_instrument.SEM.Detector.EDS.energy_resolution_MnKa': 'energy_resolution_MnKa'}</em><a class="headerlink" href="#hyperspy._signals.eds_sem.EDSSEMParametersUI.mapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.eds_sem.EDSSEMSpectrum">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eds_sem.</code><code class="descname">EDSSEMSpectrum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_sem.EDSSEMSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.eds_sem.EDSSEM_mixin" title="hyperspy._signals.eds_sem.EDSSEM_mixin"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds_sem.EDSSEM_mixin</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum" title="hyperspy._signals.eds.EDSSpectrum"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds.EDSSpectrum</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.eds_sem.EDSSEM_mixin">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eds_sem.</code><code class="descname">EDSSEM_mixin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_sem.EDSSEM_mixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="hyperspy._signals.eds_sem.EDSSEM_mixin.create_model">
<code class="descname">create_model</code><span class="sig-paren">(</span><em>auto_background=True</em>, <em>auto_add_lines=True</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_sem.EDSSEM_mixin.create_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a model for the current SEM EDS data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>auto_background</strong> (<em>boolean</em><em>, </em><em>default True</em>) &#8211; If True, adds automatically a polynomial order 6 to the model,
using the edsmodel.add_polynomial_background method.</li>
<li><strong>auto_add_lines</strong> (<em>boolean</em><em>, </em><em>default True</em>) &#8211; If True, automatically add Gaussians for all X-rays generated in
the energy range by an element using the edsmodel.add_family_lines
method.</li>
<li><strong>dictionary</strong> (<em>{None</em><em>, </em><em>dict}</em><em>, </em><em>optional</em>) &#8211; A dictionary to be used to recreate a model. Usually generated
using <code class="xref py py-meth docutils literal"><span class="pre">hyperspy.model.as_dictionary()</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>model</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>EDSSEMModel</cite> instance.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds_sem.EDSSEM_mixin.get_calibration_from">
<code class="descname">get_calibration_from</code><span class="sig-paren">(</span><em>ref</em>, <em>nb_pix=1</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_sem.EDSSEM_mixin.get_calibration_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the calibration and all metadata of a reference.</p>
<p>Primary use: To add a calibration to ripple file from INCA
software</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ref</strong> (<a class="reference internal" href="hyperspy.html#hyperspy.model.BaseModel.signal" title="hyperspy.model.BaseModel.signal"><em>signal</em></a>) &#8211; The reference contains the calibration in its
metadata</li>
<li><strong>nb_pix</strong> (<em>int</em>) &#8211; The live time (real time corrected from the &#8220;dead time&#8221;)
is divided by the number of pixel (spectrums), giving an
average live time.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">EDSSEMSpectrum</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_calibration_from</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="go">0.01</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds_sem.EDSSEM_mixin.set_microscope_parameters">
<code class="descname">set_microscope_parameters</code><span class="sig-paren">(</span><em>beam_energy=None</em>, <em>live_time=None</em>, <em>tilt_stage=None</em>, <em>azimuth_angle=None</em>, <em>elevation_angle=None</em>, <em>energy_resolution_MnKa=None</em>, <em>display=True</em>, <em>toolkit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_sem.EDSSEM_mixin.set_microscope_parameters" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Set the microscope parameters.</p>
<p>If no arguments are given, raises an interactive mode to fill
the values.</p>
<dl class="docutils">
<dt>beam_energy: float</dt>
<dd>The energy of the electron beam in keV</dd>
<dt>live_time <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In second</dd>
<dt>tilt_stage <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In degree</dd>
<dt>azimuth_angle <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In degree</dd>
<dt>elevation_angle <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In degree</dd>
<dt>energy_resolution_MnKa <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In eV</dd>
</dl>
<p>display: bool</p>
</div></blockquote>
<p>If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</p>
<blockquote>
<div>toolkit: str, iterable of strings or None</div></blockquote>
<p>If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</p>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_SEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Default value </span><span class="si">%s</span><span class="s1"> eV&#39;</span> <span class="o">%</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Acquisition_instrument</span><span class="o">.</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">SEM</span><span class="o">.</span><span class="n">Detector</span><span class="o">.</span><span class="n">EDS</span><span class="o">.</span><span class="n">energy_resolution_MnKa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_microscope_parameters</span><span class="p">(</span><span class="n">energy_resolution_MnKa</span><span class="o">=</span><span class="mf">135.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Now set to </span><span class="si">%s</span><span class="s1"> eV&#39;</span> <span class="o">%</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Acquisition_instrument</span><span class="o">.</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">SEM</span><span class="o">.</span><span class="n">Detector</span><span class="o">.</span><span class="n">EDS</span><span class="o">.</span><span class="n">energy_resolution_MnKa</span><span class="p">)</span>
<span class="go">Default value 130.0 eV</span>
<span class="go">Now set to 135.0 eV</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.eds_sem.LazyEDSSEMSpectrum">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eds_sem.</code><code class="descname">LazyEDSSEMSpectrum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_sem.LazyEDSSEMSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.eds_sem.EDSSEMSpectrum" title="hyperspy._signals.eds_sem.EDSSEMSpectrum"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds_sem.EDSSEMSpectrum</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.LazyEDSSpectrum" title="hyperspy._signals.eds.LazyEDSSpectrum"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds.LazyEDSSpectrum</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.eds_tem">
<span id="hyperspy-signals-eds-tem-module"></span><h2>hyperspy._signals.eds_tem module<a class="headerlink" href="#module-hyperspy._signals.eds_tem" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.eds_tem.EDSTEMParametersUI">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eds_tem.</code><code class="descname">EDSTEMParametersUI</code><span class="sig-paren">(</span><em>signal</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEMParametersUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hyperspy.html#hyperspy.signal.BaseSetMetadataItems" title="hyperspy.signal.BaseSetMetadataItems"><code class="xref py py-class docutils literal"><span class="pre">hyperspy.signal.BaseSetMetadataItems</span></code></a></p>
<dl class="method">
<dt id="hyperspy._signals.eds_tem.EDSTEMParametersUI.gui">
<code class="descname">gui</code><span class="sig-paren">(</span><em>display=True</em>, <em>toolkit=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEMParametersUI.gui" title="Permalink to this definition">¶</a></dt>
<dd><p>Display or return interactive GUI element if available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>display</strong> (<em>bool</em>) &#8211; If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</li>
<li><strong>toolkit</strong> (<em>str</em><em>, </em><em>iterable of strings</em><em> or </em><em>None</em>) &#8211; If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hyperspy._signals.eds_tem.EDSTEMParametersUI.mapping">
<code class="descname">mapping</code><em class="property"> = {'Acquisition_instrument.TEM.beam_energy': 'beam_energy', 'Acquisition_instrument.TEM.Stage.tilt_alpha': 'tilt_stage', 'Acquisition_instrument.TEM.Detector.EDS.live_time': 'live_time', 'Acquisition_instrument.TEM.Detector.EDS.azimuth_angle': 'azimuth_angle', 'Acquisition_instrument.TEM.Detector.EDS.elevation_angle': 'elevation_angle', 'Acquisition_instrument.TEM.Detector.EDS.energy_resolution_MnKa': 'energy_resolution_MnKa', 'Acquisition_instrument.TEM.beam_current': 'beam_current', 'Acquisition_instrument.TEM.probe_area': 'probe_area', 'Acquisition_instrument.TEM.Detector.EDS.real_time': 'real_time'}</em><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEMParametersUI.mapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.eds_tem.EDSTEMSpectrum">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eds_tem.</code><code class="descname">EDSTEMSpectrum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEMSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.eds_tem.EDSTEM_mixin" title="hyperspy._signals.eds_tem.EDSTEM_mixin"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds_tem.EDSTEM_mixin</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum" title="hyperspy._signals.eds.EDSSpectrum"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds.EDSSpectrum</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.eds_tem.EDSTEM_mixin">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eds_tem.</code><code class="descname">EDSTEM_mixin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEM_mixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="hyperspy._signals.eds_tem.EDSTEM_mixin.create_model">
<code class="descname">create_model</code><span class="sig-paren">(</span><em>auto_background=True</em>, <em>auto_add_lines=True</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEM_mixin.create_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a model for the current TEM EDS data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>auto_background</strong> (<em>boolean</em><em>, </em><em>default True</em>) &#8211; If True, adds automatically a polynomial order 6 to the model,
using the edsmodel.add_polynomial_background method.</li>
<li><strong>auto_add_lines</strong> (<em>boolean</em><em>, </em><em>default True</em>) &#8211; If True, automatically add Gaussians for all X-rays generated in
the energy range by an element using the edsmodel.add_family_lines
method.</li>
<li><strong>dictionary</strong> (<em>{None</em><em>, </em><em>dict}</em><em>, </em><em>optional</em>) &#8211; A dictionary to be used to recreate a model. Usually generated
using <code class="xref py py-meth docutils literal"><span class="pre">hyperspy.model.as_dictionary()</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>model</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>EDSTEMModel</cite> instance.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds_tem.EDSTEM_mixin.decomposition">
<code class="descname">decomposition</code><span class="sig-paren">(</span><em>normalize_poissonian_noise=True</em>, <em>navigation_mask=1.0</em>, <em>closing=True</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEM_mixin.decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Decomposition with a choice of algorithms</p>
<p>The results are stored in self.learning_results</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>normalize_poissonian_noise</strong> (<em>bool</em>) &#8211; If True, scale the SI to normalize Poissonian noise</li>
<li><strong>navigation_mask</strong> (<em>None</em><em> or </em><em>float</em><em> or </em><em>boolean numpy array</em>) &#8211; The navigation locations marked as True are not used in the
decomposition. If float is given the vacuum_mask method is used to
generate a mask with the float value as threshold.</li>
<li><strong>closing</strong> (<em>bool</em>) &#8211; If true, applied a morphologic closing to the maks obtained by
vacuum_mask.</li>
<li><strong>algorithm</strong> (<em>'svd' | 'fast_svd' | 'mlpca' | 'fast_mlpca' | 'nmf' |</em>) &#8211; &#8216;sparse_pca&#8217; | &#8216;mini_batch_sparse_pca&#8217;</li>
<li><strong>output_dimension</strong> (<em>None</em><em> or </em><em>int</em>) &#8211; number of components to keep/calculate</li>
<li><strong>centre</strong> (<em>None | 'variables' | 'trials'</em>) &#8211; If None no centring is applied. If &#8216;variable&#8217; the centring will be
performed in the variable axis. If &#8216;trials&#8217;, the centring will be
performed in the &#8216;trials&#8217; axis. It only has effect when using the
svd or fast_svd algorithms</li>
<li><strong>auto_transpose</strong> (<em>bool</em>) &#8211; If True, automatically transposes the data to boost performance.
Only has effect when using the svd of fast_svd algorithms.</li>
<li><strong>signal_mask</strong> (<em>boolean numpy array</em>) &#8211; The signal locations marked as True are not used in the
decomposition.</li>
<li><strong>var_array</strong> (<em>numpy array</em>) &#8211; Array of variance for the maximum likelihood PCA algorithm</li>
<li><strong>var_func</strong> (<a class="reference internal" href="hyperspy._components.html#hyperspy._components.arctan.Arctan.function" title="hyperspy._components.arctan.Arctan.function"><em>function</em></a><em> or </em><em>numpy array</em>) &#8211; If function, it will apply it to the dataset to obtain the
var_array. Alternatively, it can a an array with the coefficients
of a polynomial.</li>
<li><strong>polyfit</strong> &#8211; </li>
<li><strong>reproject</strong> (<em>None | signal | navigation | both</em>) &#8211; If not None, the results of the decomposition will be projected in
the selected masked area.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_TEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">si</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">si</span><span class="o">.</span><span class="n">change_dtype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">si</span><span class="o">.</span><span class="n">decomposition</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds_tem.EDSTEM_mixin.vacuum_mask" title="hyperspy._signals.eds_tem.EDSTEM_mixin.vacuum_mask"><code class="xref py py-meth docutils literal"><span class="pre">vacuum_mask()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds_tem.EDSTEM_mixin.get_calibration_from">
<code class="descname">get_calibration_from</code><span class="sig-paren">(</span><em>ref</em>, <em>nb_pix=1</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEM_mixin.get_calibration_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the calibration and all metadata of a reference.</p>
<p>Primary use: To add a calibration to ripple file from INCA
software</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ref</strong> (<a class="reference internal" href="hyperspy.html#hyperspy.model.BaseModel.signal" title="hyperspy.model.BaseModel.signal"><em>signal</em></a>) &#8211; The reference contains the calibration in its
metadata</li>
<li><strong>nb_pix</strong> (<em>int</em>) &#8211; The live time (real time corrected from the &#8220;dead time&#8221;)
is divided by the number of pixel (spectrums), giving an
average live time.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_TEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">EDSTEMSpectrum</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_TEM_Spectrum</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_calibration_from</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">axes_manager</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="go">0.020028</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds_tem.EDSTEM_mixin.quantification">
<code class="descname">quantification</code><span class="sig-paren">(</span><em>intensities</em>, <em>method</em>, <em>factors='auto'</em>, <em>composition_units='atomic'</em>, <em>navigation_mask=1.0</em>, <em>closing=True</em>, <em>plot_result=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEM_mixin.quantification" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantification using Cliff-Lorimer, the zeta-factor method, or
ionization cross sections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>intensities</strong> (<em>list of signal</em>) &#8211; the intensitiy for each X-ray lines.</li>
<li><strong>method</strong> (<em>'CL'</em><em> or </em><em>'zeta'</em><em> or </em><em>'cross_section'</em>) &#8211; Set the quantification method: Cliff-Lorimer, zeta-factor, or
ionization cross sections.</li>
<li><strong>factors</strong> (<em>list of float</em>) &#8211; The list of kfactors, zeta-factors or cross sections in same order
as intensities. Note that intensities provided by Hyperspy are
sorted by the alphabetical order of the X-ray lines.
eg. factors =[0.982, 1.32, 1.60] for [&#8216;Al_Ka&#8217;, &#8216;Cr_Ka&#8217;, &#8216;Ni_Ka&#8217;].</li>
<li><strong>composition_units</strong> (<em>'weight'</em><em> or </em><em>'atomic'</em>) &#8211; The quantification returns the composition in atomic percent by
default, but can also return weight percent if specified.</li>
<li><strong>navigation_mask</strong> (<em>None</em><em> or </em><em>float</em><em> or </em><a class="reference internal" href="hyperspy.html#hyperspy.model.BaseModel.signal" title="hyperspy.model.BaseModel.signal"><em>signal</em></a>) &#8211; The navigation locations marked as True are not used in the
quantification. If int is given the vacuum_mask method is used to
generate a mask with the int value as threhsold.
Else provides a signal with the navigation shape.</li>
<li><strong>closing</strong> (<em>bool</em>) &#8211; If true, applied a morphologic closing to the mask obtained by
vacuum_mask.</li>
<li><strong>plot_result</strong> (<em>bool</em>) &#8211; If True, plot the calculated composition. If the current
object is a single spectrum it prints the result instead.</li>
<li><strong>kwargs</strong> &#8211; The extra keyword arguments are passed to plot.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><em>A list of quantified elemental maps (signal) giving the composition of</em></li>
<li><em>the sample in weight or atomic percent.</em></li>
<li><em>If the method is &#8216;zeta&#8217; this function also returns the mass thickness</em></li>
<li><em>profile for the data.</em></li>
<li><em>If the method is &#8216;cross_section&#8217; this function also returns the atom</em></li>
<li><em>counts for each element.</em></li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_TEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_lines</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kfactors</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.450226</span><span class="p">,</span> <span class="mf">5.075602</span><span class="p">]</span> <span class="c1">#For Fe Ka and Pt La</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bw</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">estimate_background_windows</span><span class="p">(</span><span class="n">line_width</span><span class="o">=</span><span class="p">[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">background_windows</span><span class="o">=</span><span class="n">bw</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intensities</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">get_lines_intensity</span><span class="p">(</span><span class="n">background_windows</span><span class="o">=</span><span class="n">bw</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">quantification</span><span class="p">(</span><span class="n">intensities</span><span class="p">,</span> <span class="n">kfactors</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                       <span class="n">composition_units</span><span class="o">=</span><span class="s1">&#39;atomic&#39;</span><span class="p">)</span>
<span class="go">Fe (Fe_Ka): Composition = 15.41 atomic percent</span>
<span class="go">Pt (Pt_La): Composition = 84.59 atomic percent</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds_tem.EDSTEM_mixin.vacuum_mask" title="hyperspy._signals.eds_tem.EDSTEM_mixin.vacuum_mask"><code class="xref py py-meth docutils literal"><span class="pre">vacuum_mask()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds_tem.EDSTEM_mixin.set_microscope_parameters">
<code class="descname">set_microscope_parameters</code><span class="sig-paren">(</span><em>beam_energy=None</em>, <em>live_time=None</em>, <em>tilt_stage=None</em>, <em>azimuth_angle=None</em>, <em>elevation_angle=None</em>, <em>energy_resolution_MnKa=None</em>, <em>beam_current=None</em>, <em>probe_area=None</em>, <em>real_time=None</em>, <em>display=True</em>, <em>toolkit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEM_mixin.set_microscope_parameters" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Set the microscope parameters.</p>
<p>If no arguments are given, raises an interactive mode to fill
the values.</p>
<dl class="docutils">
<dt>beam_energy: float</dt>
<dd>The energy of the electron beam in keV</dd>
<dt>live_time <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In seconds</dd>
<dt>tilt_stage <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In degree</dd>
<dt>azimuth_angle <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In degree</dd>
<dt>elevation_angle <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In degree</dd>
<dt>energy_resolution_MnKa <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In eV</dd>
<dt>beam_current: float</dt>
<dd>In nA</dd>
<dt>probe_area: float</dt>
<dd>In nm^2</dd>
<dt>real_time: float</dt>
<dd>In seconds</dd>
</dl>
<p>display: bool</p>
</div></blockquote>
<p>If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</p>
<blockquote>
<div>toolkit: str, iterable of strings or None</div></blockquote>
<p>If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</p>
<blockquote>
<div><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_TEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Acquisition_instrument</span><span class="o">.</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">TEM</span><span class="o">.</span><span class="n">Detector</span><span class="o">.</span><span class="n">EDS</span><span class="o">.</span><span class="n">energy_resolution_MnKa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_microscope_parameters</span><span class="p">(</span><span class="n">energy_resolution_MnKa</span><span class="o">=</span><span class="mf">135.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Acquisition_instrument</span><span class="o">.</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">TEM</span><span class="o">.</span><span class="n">Detector</span><span class="o">.</span><span class="n">EDS</span><span class="o">.</span><span class="n">energy_resolution_MnKa</span><span class="p">)</span>
<span class="go">133.312296</span>
<span class="go">135.0</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds_tem.EDSTEM_mixin.vacuum_mask">
<code class="descname">vacuum_mask</code><span class="sig-paren">(</span><em>threshold=1.0</em>, <em>closing=True</em>, <em>opening=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEM_mixin.vacuum_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate mask of the vacuum region</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>threshold</strong> (<em>float</em>) &#8211; For a given pixel, maximum value in the energy axis below which the
pixel is considered as vacuum.</li>
<li><strong>closing</strong> (<em>bool</em>) &#8211; If true, applied a morphologic closing to the mask</li>
<li><strong>opnening</strong> (<em>bool</em>) &#8211; If true, applied a morphologic opening to the mask</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Simulate a spectrum image with vacuum region</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">EDS_TEM_Spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_vac</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">BaseSignal</span><span class="p">(</span>
<span class="go">        np.ones_like(s.data, dtype=float))*0.005</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_vac</span><span class="o">.</span><span class="n">add_poissonian_noise</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">si</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="p">[</span><span class="n">s_vac</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">si</span><span class="o">.</span><span class="n">vacuum_mask</span><span class="p">()</span><span class="o">.</span><span class="n">data</span>
<span class="go">array([False, False, False,  True], dtype=bool)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>mask</strong> &#8211; The mask of the region</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="hyperspy.html#hyperspy.model.BaseModel.signal" title="hyperspy.model.BaseModel.signal">signal</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.eds_tem.LazyEDSTEMSpectrum">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eds_tem.</code><code class="descname">LazyEDSTEMSpectrum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.LazyEDSTEMSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.eds_tem.EDSTEMSpectrum" title="hyperspy._signals.eds_tem.EDSTEMSpectrum"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds_tem.EDSTEMSpectrum</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eds.LazyEDSSpectrum" title="hyperspy._signals.eds.LazyEDSSpectrum"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds.LazyEDSSpectrum</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.eels">
<span id="hyperspy-signals-eels-module"></span><h2>hyperspy._signals.eels module<a class="headerlink" href="#module-hyperspy._signals.eels" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.eels.EELSSpectrum">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eels.</code><code class="descname">EELSSpectrum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum_mixin" title="hyperspy._signals.eels.EELSSpectrum_mixin"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eels.EELSSpectrum_mixin</span></code></a>, <a class="reference internal" href="#hyperspy._signals.signal1d.Signal1D" title="hyperspy._signals.signal1d.Signal1D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.signal1d.Signal1D</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eels.</code><code class="descname">EELSSpectrum_mixin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.add_elements">
<code class="descname">add_elements</code><span class="sig-paren">(</span><em>elements</em>, <em>include_pre_edges=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.add_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare the elemental composition of the sample.</p>
<p>The ionisation edges of the elements present in the current
energy range will be added automatically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>elements</strong> (<em>tuple of strings</em>) &#8211; The symbol of the elements. Note this input must always be
in the form of a tuple. Meaning: add_elements((&#8216;C&#8217;,)) will
work, while add_elements((&#8216;C&#8217;)) will NOT work.</li>
<li><strong>include_pre_edges</strong> (<em>bool</em>) &#8211; If True, the ionization edges with an onset below the lower
energy limit of the SI will be incluided</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">EELSSpectrum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1024</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_elements</span><span class="p">((</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.align_zero_loss_peak">
<code class="descname">align_zero_loss_peak</code><span class="sig-paren">(</span><em>calibrate=True</em>, <em>also_align=[]</em>, <em>print_stats=True</em>, <em>subpixel=True</em>, <em>mask=None</em>, <em>signal_range=None</em>, <em>show_progressbar=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.align_zero_loss_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Align the zero-loss peak.</p>
<p>This function first aligns the spectra using the result of
<cite>estimate_zero_loss_peak_centre</cite> and afterward, if subpixel is True,
proceeds to align with subpixel accuracy using <cite>align1D</cite>. The offset
is automatically correct if <cite>calibrate</cite> is True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calibrate</strong> (<em>bool</em>) &#8211; If True, set the offset of the spectral axis so that the
zero-loss peak is at position zero.</li>
<li><strong>also_align</strong> (<em>list of signals</em>) &#8211; A list containing other spectra of identical dimensions to
align using the shifts applied to the current spectrum.
If <cite>calibrate</cite> is True, the calibration is also applied to
the spectra in the list.</li>
<li><strong>print_stats</strong> (<em>bool</em>) &#8211; If True, print summary statistics of the ZLP maximum before
the aligment.</li>
<li><strong>subpixel</strong> (<em>bool</em>) &#8211; If True, perform the alignment with subpixel accuracy
using cross-correlation.</li>
<li><strong>mask</strong> (<em>Signal1D of bool data type.</em>) &#8211; It must have signal_dimension = 0 and navigation_shape equal to the
current signal. Where mask is True the shift is not computed
and set to nan.</li>
<li><strong>signal_range</strong> (<em>tuple of integers</em><em>, </em><em>tuple of floats. Optional</em>) &#8211; Will only search for the ZLP within the signal_range. If given
in integers, the range will be in index values. If given floats,
the range will be in spectrum values. Useful if there are features
in the spectrum which are more intense than the ZLP.
Default is searching in the whole signal.</li>
<li><strong>show_progressbar</strong> (<em>None</em><em> or </em><em>bool</em>) &#8211; If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s_ll</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">EELSSpectrum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_ll</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_ll</span><span class="o">.</span><span class="n">align_zero_loss_peak</span><span class="p">()</span>
</pre></div>
</div>
<p>Aligning both the lowloss signal and another signal
&gt;&gt;&gt; s = hs.signals.EELSSpectrum(np.range(1000))
&gt;&gt;&gt; s_ll.align_zero_loss_peak(also_align=[s])</p>
<p>Aligning within a narrow range of the lowloss signal
&gt;&gt;&gt; s_ll.align_zero_loss_peak(signal_range=(-10.,10.))</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum_mixin.estimate_zero_loss_peak_centre" title="hyperspy._signals.eels.EELSSpectrum_mixin.estimate_zero_loss_peak_centre"><code class="xref py py-meth docutils literal"><span class="pre">estimate_zero_loss_peak_centre()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">align1D()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">estimate_shift1D.()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Any extra keyword arguments are passed to <cite>align1D</cite>. For
more information read its docstring.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.create_model">
<code class="descname">create_model</code><span class="sig-paren">(</span><em>ll=None</em>, <em>auto_background=True</em>, <em>auto_add_edges=True</em>, <em>GOS=None</em>, <em>dictionary=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.create_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a model for the current EELS data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ll</strong> (<a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum" title="hyperspy._signals.eels.EELSSpectrum"><em>EELSSpectrum</em></a><em>, </em><em>optional</em>) &#8211; If an EELSSpectrum is provided, it will be assumed that it is
a low-loss EELS spectrum, and it will be used to simulate the
effect of multiple scattering by convolving it with the EELS
spectrum.</li>
<li><strong>auto_background</strong> (<em>boolean</em><em>, </em><em>default True</em>) &#8211; If True, and if spectrum is an EELS instance adds automatically
a powerlaw to the model and estimate the parameters by the
two-area method.</li>
<li><strong>auto_add_edges</strong> (<em>boolean</em><em>, </em><em>default True</em>) &#8211; If True, and if spectrum is an EELS instance, it will
automatically add the ionization edges as defined in the
Signal1D instance. Adding a new element to the spectrum using
the components.EELSSpectrum.add_elements method automatically
add the corresponding ionisation edges to the model.</li>
<li><strong>GOS</strong> (<em>{'hydrogenic' | 'Hartree-Slater'}</em><em>, </em><em>optional</em>) &#8211; The generalized oscillation strenght calculations to use for the
core-loss EELS edges. If None the Hartree-Slater GOS are used if
available, otherwise it uses the hydrogenic GOS.</li>
<li><strong>dictionary</strong> (<em>{None | dict}</em><em>, </em><em>optional</em>) &#8211; A dictionary to be used to recreate a model. Usually generated
using <code class="xref py py-meth docutils literal"><span class="pre">hyperspy.model.as_dictionary()</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>model</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><cite>EELSModel</cite> instance.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.estimate_elastic_scattering_intensity">
<code class="descname">estimate_elastic_scattering_intensity</code><span class="sig-paren">(</span><em>threshold</em>, <em>show_progressbar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.estimate_elastic_scattering_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Rough estimation of the elastic scattering intensity by
truncation of a EELS low-loss spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>threshold</strong> (<em>{Signal1D</em><em>, </em><em>float</em><em>, </em><em>int}</em>) &#8211; Truncation energy to estimate the intensity of the elastic
scattering. The threshold can be provided as a signal of the same
dimension as the input spectrum navigation space containing the
threshold value in the energy units. Alternatively a constant
threshold can be specified in energy/index units by passing
float/int.</li>
<li><strong>show_progressbar</strong> (<em>None</em><em> or </em><em>bool</em>) &#8211; If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I0</strong> &#8211; The elastic scattering intensity.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hyperspy._signals.signal1d.Signal1D" title="hyperspy._signals.signal1d.Signal1D">Signal1D</a></p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum_mixin.estimate_elastic_scattering_threshold" title="hyperspy._signals.eels.EELSSpectrum_mixin.estimate_elastic_scattering_threshold"><code class="xref py py-meth docutils literal"><span class="pre">estimate_elastic_scattering_threshold()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.estimate_elastic_scattering_threshold">
<code class="descname">estimate_elastic_scattering_threshold</code><span class="sig-paren">(</span><em>window=10.0</em>, <em>tol=None</em>, <em>window_length=5</em>, <em>polynomial_order=3</em>, <em>start=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.estimate_elastic_scattering_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the first inflexion point of the spectrum derivative
within a window.</p>
<p>This method assumes that the zero-loss peak is located at position zero
in all the spectra. Currently it looks for an inflexion point, that can
be a local maximum or minimum. Therefore, to estimate the elastic
scattering threshold <cite>start</cite> + <cite>window</cite> must be less than the first
maximum for all spectra (often the bulk plasmon maximum). If there is
more than one inflexion point in energy the window it selects the
smoother one what, often, but not always, is a good choice in this
case.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>window</strong> (<em>{None</em><em>, </em><em>float}</em>) &#8211; If None, the search for the local inflexion point is performed
using the full energy range. A positive float will restrict
the search to the (0,window] energy window, where window is given
in the axis units. If no inflexion point is found in this
spectral range the window value is returned instead.</li>
<li><strong>tol</strong> (<em>{None</em><em>, </em><em>float}</em>) &#8211; The threshold tolerance for the derivative. If &#8220;auto&#8221; it is
automatically calculated as the minimum value that guarantees
finding an inflexion point in all the spectra in given energy
range.</li>
<li><strong>window_length</strong> (<em>int</em>) &#8211; If non zero performs order three Savitzky-Golay smoothing
to the data to avoid falling in local minima caused by
the noise. It must be an odd interger.</li>
<li><strong>polynomial_order</strong> (<em>int</em>) &#8211; Savitzky-Golay filter polynomial order.</li>
<li><strong>start</strong> (<em>float</em>) &#8211; Position from the zero-loss peak centre from where to start
looking for the inflexion point.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>threshold</strong> &#8211; A Signal1D of the same dimension as the input spectrum
navigation space containing the estimated threshold. Where the
threshold couldn&#8217;t be estimated the value is set to nan.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hyperspy._signals.signal1d.Signal1D" title="hyperspy._signals.signal1d.Signal1D">Signal1D</a></p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum_mixin.estimate_elastic_scattering_intensity" title="hyperspy._signals.eels.EELSSpectrum_mixin.estimate_elastic_scattering_intensity"><code class="xref py py-meth docutils literal"><span class="pre">estimate_elastic_scattering_intensity()</span></code></a>, <a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum_mixin.align_zero_loss_peak" title="hyperspy._signals.eels.EELSSpectrum_mixin.align_zero_loss_peak"><code class="xref py py-meth docutils literal"><span class="pre">align_zero_loss_peak()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">find_peaks1D_ohaver()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">fourier_ratio_deconvolution.()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The main purpose of this method is to be used as input for
<cite>estimate_elastic_scattering_intensity</cite>. Indeed, for currently
achievable energy resolutions, there is not such a thing as a elastic
scattering threshold. Therefore, please be aware of the limitations of
this method when using it.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.estimate_thickness">
<code class="descname">estimate_thickness</code><span class="sig-paren">(</span><em>threshold</em>, <em>zlp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.estimate_thickness" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the thickness (relative to the mean free path)
of a sample using the log-ratio method.</p>
<p>The current EELS spectrum must be a low-loss spectrum containing
the zero-loss peak. The hyperspectrum must be well calibrated
and aligned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>threshold</strong> (<em>{Signal1D</em><em>, </em><em>float</em><em>, </em><em>int}</em>) &#8211; Truncation energy to estimate the intensity of the
elastic scattering. The threshold can be provided as a signal of
the same dimension as the input spectrum navigation space
containing the threshold value in the energy units. Alternatively a
constant threshold can be specified in energy/index units by
passing float/int.</li>
<li><strong>zlp</strong> (<em>{None</em><em>, </em><em>EELSSpectrum}</em>) &#8211; If not None the zero-loss peak intensity is calculated from the ZLP
spectrum supplied by integration using Simpson&#8217;s rule. If None
estimates the zero-loss peak intensity using
<cite>estimate_elastic_scattering_intensity</cite> by truncation.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s</strong> &#8211; The thickness relative to the MFP. It returns a Signal1D,
Signal2D or a BaseSignal, depending on the current navigation
dimensions.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#hyperspy._signals.signal1d.Signal1D" title="hyperspy._signals.signal1d.Signal1D">Signal1D</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For details see: Egerton, R. Electron Energy-Loss
Spectroscopy in the Electron Microscope. Springer-Verlag, 2011.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.estimate_zero_loss_peak_centre">
<code class="descname">estimate_zero_loss_peak_centre</code><span class="sig-paren">(</span><em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.estimate_zero_loss_peak_centre" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the posision of the zero-loss peak.</p>
<p>This function provides just a coarse estimation of the position
of the zero-loss peak centre by computing the position of the maximum
of the spectra. For subpixel accuracy use <cite>estimate_shift1D</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mask</strong> (<em>Signal1D of bool data type.</em>) &#8211; It must have signal_dimension = 0 and navigation_shape equal to the
current signal. Where mask is True the shift is not computed
and set to nan.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>zlpc</strong> &#8211; The estimated position of the maximum of the ZLP peak.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Signal1D subclass</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function only works when the zero-loss peak is the most
intense feature in the spectrum. If it is not in most cases
the spectrum can be cropped to meet this criterium.
Alternatively use <cite>estimate_shift1D</cite>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">estimate_shift1D()</span></code>, <a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum_mixin.align_zero_loss_peak" title="hyperspy._signals.eels.EELSSpectrum_mixin.align_zero_loss_peak"><code class="xref py py-meth docutils literal"><span class="pre">align_zero_loss_peak()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.fourier_log_deconvolution">
<code class="descname">fourier_log_deconvolution</code><span class="sig-paren">(</span><em>zlp</em>, <em>add_zlp=False</em>, <em>crop=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.fourier_log_deconvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs fourier-log deconvolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>zlp</strong> (<a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum" title="hyperspy._signals.eels.EELSSpectrum"><em>EELSSpectrum</em></a>) &#8211; The corresponding zero-loss peak.</li>
<li><strong>add_zlp</strong> (<em>bool</em>) &#8211; If True, adds the ZLP to the deconvolved spectrum</li>
<li><strong>crop</strong> (<em>bool</em>) &#8211; If True crop the spectrum to leave out the channels that
have been modified to decay smoothly to zero at the sides
of the spectrum.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">An EELSSpectrum containing the current data deconvolved.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For details see: Egerton, R. Electron Energy-Loss
Spectroscopy in the Electron Microscope. Springer-Verlag, 2011.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.fourier_ratio_deconvolution">
<code class="descname">fourier_ratio_deconvolution</code><span class="sig-paren">(</span><em>ll</em>, <em>fwhm=None</em>, <em>threshold=None</em>, <em>extrapolate_lowloss=True</em>, <em>extrapolate_coreloss=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.fourier_ratio_deconvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs Fourier-ratio deconvolution.</p>
<dl class="docutils">
<dt>The core-loss should have the background removed. To reduce</dt>
<dd>the noise amplication the result is convolved with a</dd>
</dl>
<p>Gaussian function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ll</strong> (<a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum" title="hyperspy._signals.eels.EELSSpectrum"><em>EELSSpectrum</em></a>) &#8211; The corresponding low-loss (ll) EELSSpectrum.</li>
<li><strong>fwhm</strong> (<em>float</em><em> or </em><em>None</em>) &#8211; Full-width half-maximum of the Gaussian function by which
the result of the deconvolution is convolved. It can be
used to select the final SNR and spectral resolution. If
None, the FWHM of the zero-loss peak of the low-loss is
estimated and used.</li>
<li><strong>threshold</strong> (<em>{None</em><em>, </em><em>float}</em>) &#8211; <p>Truncation energy to estimate the intensity of the
elastic scattering. If None the threshold is taken as the</p>
<blockquote>
<div>first minimum after the ZLP centre.</div></blockquote>
</li>
<li><strong>extrapolate_coreloss</strong> (<em>extrapolate_lowloss</em><em>,</em>) &#8211; If True the signals are extrapolated using a power law,</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For details see: Egerton, R. Electron Energy-Loss
Spectroscopy in the Electron Microscope. Springer-Verlag, 2011.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.generate_subshells">
<code class="descname">generate_subshells</code><span class="sig-paren">(</span><em>include_pre_edges=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.generate_subshells" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the subshells for the current energy range for the
elements present in self.elements</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>include_pre_edges</strong> (<em>bool</em>) &#8211; If True, the ionization edges with an onset below the lower
energy limit of the SI will be incluided</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.kramers_kronig_analysis">
<code class="descname">kramers_kronig_analysis</code><span class="sig-paren">(</span><em>zlp=None</em>, <em>iterations=1</em>, <em>n=None</em>, <em>t=None</em>, <em>delta=0.5</em>, <em>full_output=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.kramers_kronig_analysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the complex
dielectric function from a single scattering distribution (SSD) using
the Kramers-Kronig relations.</p>
<p>It uses the FFT method as in <a class="reference internal" href="../user_guide/bibliography.html#egerton2011" id="id6">[Egerton2011]</a>.  The SSD is an
EELSSpectrum instance containing SSD low-loss EELS with no zero-loss
peak. The internal loop is devised to approximately subtract the
surface plasmon contribution supposing an unoxidized planar surface and
neglecting coupling between the surfaces. This method does not account
for retardation effects, instrumental broading and surface plasmon
excitation in particles.</p>
<p>Note that either refractive index or thickness are required.
If both are None or if both are provided an exception is raised.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>zlp</strong> (<em>{None</em><em>, </em><em>number</em><em>, </em><em>Signal1D}</em>) &#8211; ZLP intensity. It is optional (can be None) if <cite>t</cite> is None and <cite>n</cite>
is not None and the thickness estimation is not required. If <cite>t</cite>
is not None, the ZLP is required to perform the normalization and
if <cite>t</cite> is not None, the ZLP is required to calculate the thickness.
If the ZLP is the same for all spectra, the integral of the ZLP
can be provided as a number. Otherwise, if the ZLP intensity is not
the same for all spectra, it can be provided as i) a Signal1D
of the same dimensions as the current signal containing the ZLP
spectra for each location ii) a BaseSignal of signal dimension 0
and navigation_dimension equal to the current signal containing the
integrated ZLP intensity.</li>
<li><strong>iterations</strong> (<em>int</em>) &#8211; Number of the iterations for the internal loop to remove the
surface plasmon contribution. If 1 the surface plasmon contribution
is not estimated and subtracted (the default is 1).</li>
<li><strong>n</strong> (<em>{None</em><em>, </em><em>float}</em>) &#8211; The medium refractive index. Used for normalization of the
SSD to obtain the energy loss function. If given the thickness
is estimated and returned. It is only required when <cite>t</cite> is None.</li>
<li><strong>t</strong> (<em>{None</em><em>, </em><em>number</em><em>, </em><em>Signal1D}</em>) &#8211; The sample thickness in nm. Used for normalization of the
SSD to obtain the energy loss function. It is only required when
<cite>n</cite> is None. If the thickness is the same for all spectra it can be
given by a number. Otherwise, it can be provided as a BaseSignal
with signal dimension 0 and navigation_dimension equal to the
current signal.</li>
<li><strong>delta</strong> (<em>float</em>) &#8211; A small number (0.1-0.5 eV) added to the energy axis in
specific steps of the calculation the surface loss correction to
improve stability.</li>
<li><strong>full_output</strong> (<em>bool</em>) &#8211; If True, return a dictionary that contains the estimated
thickness if <cite>t</cite> is None and the estimated surface plasmon
excitation and the spectrum corrected from surface plasmon
excitations if <cite>iterations</cite> &gt; 1.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><p class="first"><strong>eps</strong> (<em>DielectricFunction instance</em>) &#8211;</p>
<dl class="docutils">
<dt>The complex dielectric function results,</dt>
<dd><p class="first last">$epsilon = epsilon_1 + i*epsilon_2$,</p>
</dd>
</dl>
<p>contained in an DielectricFunction instance.</p>
</li>
<li><p class="first"><strong>output</strong> (<em>Dictionary (optional)</em>) &#8211; A dictionary of optional outputs with the following keys:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">thickness</span></code></dt>
<dd><p class="first last">The estimated  thickness in nm calculated by normalization of
the SSD (only when <cite>t</cite> is None)</p>
</dd>
<dt><code class="docutils literal"><span class="pre">surface</span> <span class="pre">plasmon</span> <span class="pre">estimation</span></code></dt>
<dd><p class="first last">The estimated surface plasmon excitation (only if
<cite>iterations</cite> &gt; 1.)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal"><span class="pre">ValuerError</span></code> &#8211; If both <cite>n</cite> and <cite>t</cite> are undefined (None).</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">AttribureError</span></code> &#8211; If the beam_energy or the collection semi-angle are not defined in
metadata.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method is based in Egerton&#8217;s Matlab code <a class="reference internal" href="../user_guide/bibliography.html#egerton2011" id="id7">[Egerton2011]</a> with some
minor differences:</p>
<ul class="simple">
<li>The integrals are performed using the simpsom rule instead of using
a summation.</li>
<li>The wrap-around problem when computing the ffts is workarounded by
padding the signal instead of substracting the reflected tail.</li>
</ul>
<table class="docutils citation" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Egerton2011]</td><td>Ray Egerton, &#8220;Electron Energy-Loss
Spectroscopy in the Electron Microscope&#8221;, Springer-Verlag, 2011.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.power_law_extrapolation">
<code class="descname">power_law_extrapolation</code><span class="sig-paren">(</span><em>window_size=20</em>, <em>extrapolation_size=1024</em>, <em>add_noise=False</em>, <em>fix_neg_r=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.power_law_extrapolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrapolate the spectrum to the right using a powerlaw</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>window_size</strong> (<em>int</em>) &#8211; The number of channels from the right side of the
spectrum that are used to estimate the power law
parameters.</li>
<li><strong>extrapolation_size</strong> (<em>int</em>) &#8211; Size of the extrapolation in number of channels</li>
<li><strong>add_noise</strong> (<em>bool</em>) &#8211; If True, add poissonian noise to the extrapolated spectrum.</li>
<li><strong>fix_neg_r</strong> (<em>bool</em>) &#8211; If True, the negative values for the &#8220;components.PowerLaw&#8221;
parameter r will be flagged and the extrapolation will be
done with a constant zero-value.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">A new spectrum, with the extrapolation.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.rebin">
<code class="descname">rebin</code><span class="sig-paren">(</span><em>new_shape=None</em>, <em>scale=None</em>, <em>crop=True</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.rebin" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebin array.</p>
<p>Rebin the signal into a smaller or larger shape, based on linear
interpolation. Specify <strong>either</strong> new_shape or scale.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_shape</strong> (<em>a list of floats</em><em> or </em><em>integer</em><em>, </em><em>default None</em>) &#8211; For each dimension specify the new_shape. This will
then be converted into a scale.</li>
<li><strong>scale</strong> (<em>a list of floats</em><em> or </em><em>integer</em><em>, </em><em>default None</em>) &#8211; For each dimension specify the new:old pixel ratio, e.g. a ratio of 1
is no binning and a ratio of 2 means that each pixel in the new
spectrum is twice the size of the pixels in the old spectrum.
The length of the list should match the dimension of the numpy array.
<strong>*Note : Only one of scale or new_shape should be specified otherwise
the function will not run*</strong></li>
<li><strong>crop</strong> (<em>bool</em><em>, </em><em>default True</em>) &#8211; <p>When binning by a non-integer number of pixels it is likely that
the final row in each dimension contains less than the full quota to
fill one pixel.</p>
<p>e.g. 5*5 array binned by 2.1 will produce two rows containing 2.1
pixels and one row containing only 0.8 pixels worth. Selection of
crop=&#8217;True&#8217; or crop=&#8217;False&#8217; determines whether or not this
&#8216;black&#8217; line is cropped from the final binned array or not.</p>
<p><em>Please note that if crop=False is used, the final row in each
dimension may appear black, if a fractional number of pixels are left
over. It can be removed but has been left to preserve total counts
before and after binning.</em></p>
</li>
<li><strong>out</strong> (<em>{Signal</em><em>, </em><em>None}</em>) &#8211; If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Signal subclass</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">EDSTEMSpectrum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectrum</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
<span class="go">&lt;EDXTEMSpectrum, title: dimensions: (4, 4|10)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;Sum = &#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">data</span><span class="p">))))</span>
<span class="go">Sum = 164.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="go">&lt;EDSTEMSpectrum, title: dimensions (2, 2|2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sum = &#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">data</span><span class="p">))))</span>
<span class="go">Sum =  164.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.richardson_lucy_deconvolution">
<code class="descname">richardson_lucy_deconvolution</code><span class="sig-paren">(</span><em>psf</em>, <em>iterations=15</em>, <em>mask=None</em>, <em>show_progressbar=None</em>, <em>parallel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.richardson_lucy_deconvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>1D Richardson-Lucy Poissonian deconvolution of
the spectrum by the given kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>iterations</strong> (<em>int</em>) &#8211; Number of iterations of the deconvolution. Note that
increasing the value will increase the noise amplification.</li>
<li><strong>psf</strong> (<a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum" title="hyperspy._signals.eels.EELSSpectrum"><em>EELSSpectrum</em></a>) &#8211; It must have the same signal dimension as the current
spectrum and a spatial dimension of 0 or the same as the
current spectrum.</li>
<li><strong>show_progressbar</strong> (<em>None</em><em> or </em><em>bool</em>) &#8211; If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</li>
<li><strong>parallel</strong> (<em>{None</em><em>,</em><em>bool</em><em>,</em><em>int}</em>) &#8211; if True, the deconvolution will be performed in a threaded (parallel)
manner.</li>
<li><strong>Notes</strong> &#8211; </li>
<li><strong>-----</strong> &#8211; </li>
<li><strong>details on the algorithm see Gloter</strong><strong>, </strong><strong>A.</strong><strong>, </strong><strong>A. Douiri</strong><strong>,</strong> (<em>For</em>) &#8211; </li>
<li><strong>Tence</strong><strong>, </strong><strong>and C. Colliex. “Improving Energy Resolution of</strong> (<em>M.</em>) &#8211; </li>
<li><strong>Spectra</strong> (<em>EELS</em>) &#8211; </li>
<li><strong>96</strong><strong>, </strong><strong>no. 3–4</strong><strong> (</strong><strong>September 2003</strong><strong>)</strong> (<em>Ultramicroscopy</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum_mixin.set_microscope_parameters">
<code class="descname">set_microscope_parameters</code><span class="sig-paren">(</span><em>beam_energy=None</em>, <em>convergence_angle=None</em>, <em>collection_angle=None</em>, <em>toolkit=None</em>, <em>display=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum_mixin.set_microscope_parameters" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Set the microscope parameters that are necessary to calculate
the GOS.</p>
<p>If not all of them are defined, in interactive mode
raises an UI item to fill the values</p>
<dl class="docutils">
<dt>beam_energy: float</dt>
<dd>The energy of the electron beam in keV</dd>
<dt>convengence_angle <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The microscope convergence semi-angle in mrad.</dd>
<dt>collection_angle <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>The collection semi-angle in mrad.</dd>
</dl>
<p>toolkit: str, iterable of strings or None</p>
</div></blockquote>
<p>If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</p>
<blockquote>
<div>display: bool</div></blockquote>
<p>If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.eels.EELSTEMParametersUI">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eels.</code><code class="descname">EELSTEMParametersUI</code><span class="sig-paren">(</span><em>signal</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSTEMParametersUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hyperspy.html#hyperspy.signal.BaseSetMetadataItems" title="hyperspy.signal.BaseSetMetadataItems"><code class="xref py py-class docutils literal"><span class="pre">hyperspy.signal.BaseSetMetadataItems</span></code></a></p>
<dl class="method">
<dt id="hyperspy._signals.eels.EELSTEMParametersUI.gui">
<code class="descname">gui</code><span class="sig-paren">(</span><em>display=True</em>, <em>toolkit=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSTEMParametersUI.gui" title="Permalink to this definition">¶</a></dt>
<dd><p>Display or return interactive GUI element if available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>display</strong> (<em>bool</em>) &#8211; If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</li>
<li><strong>toolkit</strong> (<em>str</em><em>, </em><em>iterable of strings</em><em> or </em><em>None</em>) &#8211; If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="hyperspy._signals.eels.EELSTEMParametersUI.mapping">
<code class="descname">mapping</code><em class="property"> = {'Acquisition_instrument.TEM.convergence_angle': 'convergence_angle', 'Acquisition_instrument.TEM.beam_energy': 'beam_energy', 'Acquisition_instrument.TEM.Detector.EELS.collection_angle': 'collection_angle'}</em><a class="headerlink" href="#hyperspy._signals.eels.EELSTEMParametersUI.mapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.eels.LazyEELSSpectrum">
<em class="property">class </em><code class="descclassname">hyperspy._signals.eels.</code><code class="descname">LazyEELSSpectrum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.LazyEELSSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum" title="hyperspy._signals.eels.EELSSpectrum"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eels.EELSSpectrum</span></code></a>, <a class="reference internal" href="#hyperspy._signals.signal1d.LazySignal1D" title="hyperspy._signals.signal1d.LazySignal1D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.signal1d.LazySignal1D</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.hologram_image">
<span id="hyperspy-signals-hologram-image-module"></span><h2>hyperspy._signals.hologram_image module<a class="headerlink" href="#module-hyperspy._signals.hologram_image" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.hologram_image.HologramImage">
<em class="property">class </em><code class="descclassname">hyperspy._signals.hologram_image.</code><code class="descname">HologramImage</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.hologram_image.HologramImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.signal2d.Signal2D" title="hyperspy._signals.signal2d.Signal2D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.signal2d.Signal2D</span></code></a></p>
<p>Image subclass for holograms acquired via off-axis electron holography.</p>
<dl class="method">
<dt id="hyperspy._signals.hologram_image.HologramImage.estimate_sideband_position">
<code class="descname">estimate_sideband_position</code><span class="sig-paren">(</span><em>ap_cb_radius=None</em>, <em>sb='lower'</em>, <em>show_progressbar=False</em>, <em>parallel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.hologram_image.HologramImage.estimate_sideband_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the position of the sideband and returns its position.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ap_cb_radius</strong> (<em>float</em><em>, </em><em>None</em>) &#8211; The aperture radius used to mask out the centerband.</li>
<li><strong>sb</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; Chooses which sideband is taken. &#8216;lower&#8217; or &#8216;upper&#8217;</li>
<li><strong>show_progressbar</strong> (<em>boolean</em>) &#8211; Shows progressbar while iterating over different slices of the signal (passes the parameter to map method).</li>
<li><strong>parallel</strong> (<em>bool</em>) &#8211; Estimate the positions in parallel</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Signal1D instance of sideband positions (<a class="reference internal" href="hyperspy.html#hyperspy.roi.RectangularROI.y" title="hyperspy.roi.RectangularROI.y">y</a>, <a class="reference internal" href="hyperspy.html#hyperspy.roi.RectangularROI.x" title="hyperspy.roi.RectangularROI.x">x</a>), referred to the unshifted FFT.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hyperspy.api</span> <span class="k">as</span> <span class="nn">hs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">object_hologram</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sb_position</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">estimate_sideband_position</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sb_position</span><span class="o">.</span><span class="n">data</span>
</pre></div>
</div>
<p>array([124, 452])</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.hologram_image.HologramImage.estimate_sideband_size">
<code class="descname">estimate_sideband_size</code><span class="sig-paren">(</span><em>sb_position</em>, <em>show_progressbar=False</em>, <em>parallel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.hologram_image.HologramImage.estimate_sideband_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the size of the sideband and returns its size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sb_position</strong> (:class:<a href="#id9"><span class="problematic" id="id10">`</span></a>~hyperspy.signals.BaseSignal) &#8211; The sideband position (y, x), referred to the non-shifted FFT.</li>
<li><strong>show_progressbar</strong> (<em>boolean</em>) &#8211; Shows progressbar while iterating over different slices of the signal (passes the parameter to map method).</li>
<li><strong>parallel</strong> (<em>bool</em>) &#8211; Estimate the sizes in parallel</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Signal 1D instance with sideband size, referred to the unshifted FFT.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hyperspy.api</span> <span class="k">as</span> <span class="nn">hs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">object_hologram</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sb_position</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">estimate_sideband_position</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sb_size</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">estimate_sideband_size</span><span class="p">(</span><span class="n">sb_position</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sb_size</span><span class="o">.</span><span class="n">data</span>
</pre></div>
</div>
<p>array([ 68.87670143])</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.hologram_image.HologramImage.reconstruct_phase">
<code class="descname">reconstruct_phase</code><span class="sig-paren">(</span><em>reference=None</em>, <em>sb_size=None</em>, <em>sb_smoothness=None</em>, <em>sb_unit=None</em>, <em>sb='lower'</em>, <em>sb_position=None</em>, <em>output_shape=None</em>, <em>plotting=False</em>, <em>show_progressbar=False</em>, <em>store_parameters=True</em>, <em>parallel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.hologram_image.HologramImage.reconstruct_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct electron holograms. Operates on multidimensional
hyperspy signals. There are several usage schemes:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Reconstruct 1d or Nd hologram without reference</li>
<li>Reconstruct 1d or Nd hologram using single reference hologram</li>
</ol>
<p>3. Reconstruct Nd hologram using Nd reference hologram (applies each
reference to each hologram in Nd stack)</p>
<p>The reconstruction parameters (sb_position, sb_size, sb_smoothness)
have to be 1d or to have same dimensionality as the hologram.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>reference</strong> (ndarray, :class:<a href="#id11"><span class="problematic" id="id12">`</span></a>~hyperspy.signals.Signal2D, None) &#8211; Vacuum reference hologram.</li>
<li><strong>sb_size</strong> (float, ndarray, :class:<a href="#id13"><span class="problematic" id="id14">`</span></a>~hyperspy.signals.BaseSignal, None) &#8211; Sideband radius of the aperture in corresponding unit (see
&#8216;sb_unit&#8217;). If None, the radius of the aperture is set to 1/3 of
the distance between sideband and center band.</li>
<li><strong>sb_smoothness</strong> (float, ndarray, :class:<a href="#id15"><span class="problematic" id="id16">`</span></a>~hyperspy.signals.BaseSignal, None) &#8211; Smoothness of the aperture in the same unit as sb_size.</li>
<li><strong>sb_unit</strong> (<em>str</em><em>, </em><em>None</em>) &#8211; Unit of the two sideband parameters &#8216;sb_size&#8217; and &#8216;sb_smoothness&#8217;.
Default: None - Sideband size given in pixels
&#8216;nm&#8217;: Size and smoothness of the aperture are given in 1/nm.
&#8216;mrad&#8217;: Size and smoothness of the aperture are given in mrad.</li>
<li><strong>sb</strong> (<em>str</em><em>, </em><em>None</em>) &#8211; Select which sideband is selected. &#8216;upper&#8217; or &#8216;lower&#8217;.</li>
<li><strong>sb_position</strong> (tuple, :class:<a href="#id17"><span class="problematic" id="id18">`</span></a>~hyperspy.signals.Signal1D, None) &#8211; The sideband position (y, x), referred to the non-shifted FFT. If
None, sideband is determined automatically from FFT.</li>
<li><strong>output_shape</strong> (<em>tuple</em><em>, </em><em>None</em>) &#8211; Choose a new output shape. Default is the shape of the input
hologram. The output shape should not be larger than the input
shape.</li>
<li><strong>plotting</strong> (<em>boolean</em>) &#8211; Shows details of the reconstruction (i.e. SB selection).</li>
<li><strong>show_progressbar</strong> (<em>boolean</em>) &#8211; Shows progressbar while iterating over different slices of the
signal (passes the parameter to map method).</li>
<li><strong>parallel</strong> (<em>bool</em>) &#8211; Run the reconstruction in parallel</li>
<li><strong>store_parameters</strong> (<em>boolean</em>) &#8211; Store reconstruction parameters in metadata</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>wave</strong> &#8211; Reconstructed electron wave. By default object wave is devided by
reference wave</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">:class:<a href="#id19"><span class="problematic" id="id20">`</span></a>~hyperspy.signals.WaveImage</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hyperspy.api</span> <span class="k">as</span> <span class="nn">hs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">example_signals</span><span class="o">.</span><span class="n">object_hologram</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sb_position</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">estimate_sideband_position</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sb_size</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">estimate_sideband_size</span><span class="p">(</span><span class="n">sb_position</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sb_size</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wave</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">reconstruct_phase</span><span class="p">(</span><span class="n">sb_position</span><span class="o">=</span><span class="n">sb_position</span><span class="p">,</span> <span class="n">sb_size</span><span class="o">=</span><span class="n">sb_size</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.hologram_image.HologramImage.set_microscope_parameters">
<code class="descname">set_microscope_parameters</code><span class="sig-paren">(</span><em>beam_energy=None</em>, <em>biprism_voltage=None</em>, <em>tilt_stage=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.hologram_image.HologramImage.set_microscope_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the microscope parameters.</p>
<p>If no arguments are given, raises an interactive mode to fill
the values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>beam_energy</strong> (<em>float</em>) &#8211; The energy of the electron beam in keV</li>
<li><strong>biprism_voltage</strong> (<em>float</em>) &#8211; In volts</li>
<li><strong>tilt_stage</strong> (<em>float</em>) &#8211; In degrees</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_microscope_parameters</span><span class="p">(</span><span class="n">beam_energy</span><span class="o">=</span><span class="mf">300.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Now set to </span><span class="si">%s</span><span class="s1"> keV&#39;</span> <span class="o">%</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Acquisition_instrument</span><span class="o">.</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">TEM</span><span class="o">.</span><span class="n">beam_energy</span><span class="p">)</span>
</pre></div>
</div>
<p>Now set to 300.0 keV</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.hologram_image.LazyHologramImage">
<em class="property">class </em><code class="descclassname">hyperspy._signals.hologram_image.</code><code class="descname">LazyHologramImage</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.hologram_image.LazyHologramImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.lazy.LazySignal" title="hyperspy._signals.lazy.LazySignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.lazy.LazySignal</span></code></a>, <a class="reference internal" href="#hyperspy._signals.hologram_image.HologramImage" title="hyperspy._signals.hologram_image.HologramImage"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.hologram_image.HologramImage</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.lazy">
<span id="hyperspy-signals-lazy-module"></span><h2>hyperspy._signals.lazy module<a class="headerlink" href="#module-hyperspy._signals.lazy" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.lazy.LazySignal">
<em class="property">class </em><code class="descclassname">hyperspy._signals.lazy.</code><code class="descname">LazySignal</code><span class="sig-paren">(</span><em>data</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hyperspy.html#hyperspy.signal.BaseSignal" title="hyperspy.signal.BaseSignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy.signal.BaseSignal</span></code></a></p>
<p>A Lazy Signal instance that delays computation until explicitly saved
(assuming storing the full result of computation in memory is not feasible)</p>
<dl class="method">
<dt id="hyperspy._signals.lazy.LazySignal.change_dtype">
<code class="descname">change_dtype</code><span class="sig-paren">(</span><em>dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal.change_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the data type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtype</strong> (<em>str</em><em> or </em><a class="reference internal" href="hyperspy.io_plugins.html#hyperspy.io_plugins.digital_micrograph.ImageObject.dtype" title="hyperspy.io_plugins.digital_micrograph.ImageObject.dtype"><em>dtype</em></a>) &#8211; Typecode or data-type to which the array is cast. In addition to all
standard numpy dtypes HyperSpy supports four extra dtypes for RGB
images: &#8220;rgb8&#8221;, &#8220;rgba8&#8221;, &#8220;rgb16&#8221; and &#8220;rgba16&#8221;. Changing from and to
any rgbx dtype is more constrained than most other dtype
conversions. To change to a rgbx dtype the signal dimension must be
1, its size 3(4) for rgb(rgba) dtypes, the dtype uint8(uint16) for
rgbx8(rgbx16) and the navigation dimension at least 2. After
conversion the signal dimension becomes 2. The dtype of images of
dtype rgbx8(rgbx16) can only be changed to uint8(uint16) and the
signal dimension becomes 1.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span>
<span class="go">array([1, 2, 3, 4, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">change_dtype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span>
<span class="go">array([ 1.,  2.,  3.,  4.,  5.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.lazy.LazySignal.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em>progressbar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to store the full signal in memory..</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.lazy.LazySignal.decomposition">
<code class="descname">decomposition</code><span class="sig-paren">(</span><em>output_dimension</em>, <em>normalize_poissonian_noise=False</em>, <em>algorithm='PCA'</em>, <em>signal_mask=None</em>, <em>navigation_mask=None</em>, <em>get=&lt;function get&gt;</em>, <em>num_chunks=None</em>, <em>reproject=True</em>, <em>bounds=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal.decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Incremental (Batch) decomposition on the data, keeping n
significant components.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>output_dimension</strong> (<em>int</em>) &#8211; the number of significant components to keep</li>
<li><strong>normalize_poissonian_noise</strong> (<em>bool</em>) &#8211; If True, scale the SI to normalize Poissonian noise</li>
<li><strong>algorithm</strong> (<em>str</em>) &#8211; One of (&#8216;PCA&#8217;, &#8216;ORPCA&#8217;, &#8216;ONMF&#8217;). By default (&#8216;PCA&#8217;) IncrementalPCA
from scikit-learn is run.</li>
<li><strong>get</strong> (<em>dask scheduler</em>) &#8211; the dask scheduler to use for computations;
default <cite>dask.threaded.get</cite></li>
<li><strong>num_chunks</strong> (<em>int</em>) &#8211; the number of dask chunks to pass to the decomposition model.
More chunks require more memory, but should run faster. Will be
increased to contain atleast output_dimension signals.</li>
<li><strong>navigation_mask</strong> (<em>{BaseSignal</em><em>, </em><em>numpy array</em><em>, </em><em>dask array}</em>) &#8211; The navigation locations marked as True are not used in the
decompostion.</li>
<li><strong>signal_mask</strong> (<em>{BaseSignal</em><em>, </em><em>numpy array</em><em>, </em><em>dask array}</em>) &#8211; The signal locations marked as True are not used in the
decomposition.</li>
<li><strong>reproject</strong> (<em>bool</em>) &#8211; Reproject data on the learnt components (factors) after learning.</li>
<li><strong>bounds</strong> (<em>{tuple</em><em>, </em><em>bool}</em>) &#8211; The (min, max) values of the data to normalize before learning.
If tuple (min, max), those values will be used for normalization.
If True, extremes will be looked up (expensive), default.
If False, no normalization is done (learning may be very slow).
If normalize_poissonian_noise is True, this cannot be True.</li>
<li><strong>**kwargs</strong> &#8211; passed to the partial_fit/fit functions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>Various algorithm parameters and their default values:</dt>
<dd><dl class="first last docutils">
<dt>ONMF:</dt>
<dd>lambda1=1,
kappa=1,
robust=False,
store_r=False
batch_size=None</dd>
<dt>ORPCA:</dt>
<dd>fast=True,
lambda1=None,
lambda2=None,
method=None,
learning_rate=None,
init=None,
training_samples=None,
momentum=None</dd>
<dt>PCA:</dt>
<dd>batch_size=None,
copy=True,
white=False</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.lazy.LazySignal.diff">
<code class="descname">diff</code><span class="sig-paren">(</span><em>axis</em>, <em>order=1</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the n-th order discrete difference along
given axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>axis</strong> (<em>{int | string | axis}</em>) &#8211; The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</li>
<li><strong>order</strong> (<em>int</em>) &#8211; the order of the derivative</li>
<li><strong>out</strong> (<em>{Signal</em><em>, </em><em>None}</em>) &#8211; If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">max()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">min()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">sum()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">mean()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">std()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">var()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">indexmax()</span></code>, <a class="reference internal" href="#hyperspy._signals.lazy.LazySignal.valuemax" title="hyperspy._signals.lazy.LazySignal.valuemax"><code class="xref py py-meth docutils literal"><span class="pre">valuemax()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">amax()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1023)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.lazy.LazySignal.get_histogram">
<code class="descname">get_histogram</code><span class="sig-paren">(</span><em>bins='freedman'</em>, <em>out=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal.get_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a histogram of the signal data.</p>
<p>More sophisticated algorithms for determining bins can be used.
Aside from the <cite>bins</cite> argument allowing a string specified how bins
are computed, the parameters are the same as numpy.histogram().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bins</strong> (<em>int</em><em> or </em><em>list</em><em> or </em><em>str</em><em>, </em><em>optional</em>) &#8211; If bins is a string, then it must be one of:
&#8216;knuth&#8217; : use Knuth&#8217;s rule to determine bins
&#8216;scotts&#8217; : use Scott&#8217;s rule to determine bins
&#8216;freedman&#8217; : use the Freedman-diaconis rule to determine bins
&#8216;blocks&#8217; : use bayesian blocks for dynamic bin widths</li>
<li><strong>range_bins</strong> (<em>tuple</em><em> or </em><em>None</em><em>, </em><em>optional</em>) &#8211; the minimum and maximum range for the histogram. If not specified,
it will be (x.min(), x.max())</li>
<li><strong>out</strong> (<em>{Signal</em><em>, </em><em>None}</em>) &#8211; If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</li>
<li><strong>**kwargs</strong> &#8211; other keyword arguments (weight and density) are described in
np.histogram().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>hist_spec</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">An 1D spectrum instance containing the histogram.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">print_summary_statistics()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">astroML.density_estimation.histogram()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.histogram()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The lazy version of the algorithm does not support &#8216;knuth&#8217; and &#8216;blocks&#8217;
bins arguments.
The number of bins estimators are taken from AstroML. Read
their documentation for more info.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>
<span class="go">Plot the data histogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_histogram</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Plot the histogram of the signal at the current coordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_current_signal</span><span class="p">()</span><span class="o">.</span><span class="n">get_histogram</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.lazy.LazySignal.integrate_simpson">
<code class="descname">integrate_simpson</code><span class="sig-paren">(</span><em>axis</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal.integrate_simpson" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the result of calculating the integral
of the signal along an axis using Simpson&#8217;s rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>axis</strong> (<em>{int | string | axis}</em>) &#8211; The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</li>
<li><strong>out</strong> (<em>{Signal</em><em>, </em><em>None}</em>) &#8211; If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Signal</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">max()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">min()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">sum()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">mean()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">std()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">var()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">indexmax()</span></code>, <a class="reference internal" href="#hyperspy._signals.lazy.LazySignal.valuemax" title="hyperspy._signals.lazy.LazySignal.valuemax"><code class="xref py py-meth docutils literal"><span class="pre">valuemax()</span></code></a>, <code class="xref py py-meth docutils literal"><span class="pre">amax()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.lazy.LazySignal.rebin">
<code class="descname">rebin</code><span class="sig-paren">(</span><em>new_shape=None</em>, <em>scale=None</em>, <em>crop=False</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal.rebin" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebin array.</p>
<p>Rebin the signal into a smaller or larger shape, based on linear
interpolation. Specify <strong>either</strong> new_shape or scale.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_shape</strong> (<em>a list of floats</em><em> or </em><em>integer</em><em>, </em><em>default None</em>) &#8211; For each dimension specify the new_shape. This will
then be converted into a scale.</li>
<li><strong>scale</strong> (<em>a list of floats</em><em> or </em><em>integer</em><em>, </em><em>default None</em>) &#8211; For each dimension specify the new:old pixel ratio, e.g. a ratio of 1
is no binning and a ratio of 2 means that each pixel in the new
spectrum is twice the size of the pixels in the old spectrum.
The length of the list should match the dimension of the numpy array.
<strong>*Note : Only one of scale or new_shape should be specified otherwise
the function will not run*</strong></li>
<li><strong>crop</strong> (<em>bool</em><em>, </em><em>default True</em>) &#8211; <p>When binning by a non-integer number of pixels it is likely that
the final row in each dimension contains less than the full quota to
fill one pixel.</p>
<p>e.g. 5*5 array binned by 2.1 will produce two rows containing 2.1
pixels and one row containing only 0.8 pixels worth. Selection of
crop=&#8217;True&#8217; or crop=&#8217;False&#8217; determines whether or not this
&#8216;black&#8217; line is cropped from the final binned array or not.</p>
<p><em>Please note that if crop=False is used, the final row in each
dimension may appear black, if a fractional number of pixels are left
over. It can be removed but has been left to preserve total counts
before and after binning.</em></p>
</li>
<li><strong>out</strong> (<em>{Signal</em><em>, </em><em>None}</em>) &#8211; If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Signal subclass</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">EDSTEMSpectrum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectrum</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
<span class="go">&lt;EDXTEMSpectrum, title: dimensions: (4, 4|10)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;Sum = &#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">data</span><span class="p">))))</span>
<span class="go">Sum = 164.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="go">&lt;EDSTEMSpectrum, title: dimensions (2, 2|2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sum = &#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">data</span><span class="p">))))</span>
<span class="go">Sum =  164.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.lazy.LazySignal.swap_axes">
<code class="descname">swap_axes</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal.swap_axes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy._signals.lazy.LazySignal.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposes the signal to have the required signal and navigation
axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>navigation_axes</strong> (<em>signal_axes</em><em>,</em>) &#8211; With the exception of both parameters getting iterables, generally
one has to be None (i.e. &#8220;floating&#8221;). The other one specifies
either the required number or explicitly the axes to move to the
corresponding space.
If both are iterables, full control is given as long as all axes
are assigned to one space only.</li>
<li><strong>optimize</strong> (<em>bool</em><em> [</em><em>False</em><em>]</em>) &#8211; If the data should be re-ordered in memory, most likely making a
copy. Ensures the fastest available iteration at the expense of
memory.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">T()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">as_signal2D()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">as_signal1D()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">hs.transpose()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># just create a signal with many distinct dimensions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;BaseSignal, title: , dimensions: (|9, 8, 7, 6, 5, 4, 3, 2, 1)&gt;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1"># swap signal and navigation spaces</span>
<span class="go">&lt;BaseSignal, title: , dimensions: (9, 8, 7, 6, 5, 4, 3, 2, 1|)&gt;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">T</span> <span class="c1"># a shortcut for no arguments</span>
<span class="go">&lt;BaseSignal, title: , dimensions: (9, 8, 7, 6, 5, 4, 3, 2, 1|)&gt;</span>
</pre></div>
</div>
<p># roll to leave 5 axes in navigation space
&gt;&gt;&gt; s.transpose(signal_axes=5)
&lt;BaseSignal, title: , dimensions: (4, 3, 2, 1|9, 8, 7, 6, 5)&gt;</p>
<p># roll leave 3 axes in navigation space
&gt;&gt;&gt; s.transpose(navigation_axes=3)
&lt;BaseSignal, title: , dimensions: (3, 2, 1|9, 8, 7, 6, 5, 4)&gt;</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 3 explicitly defined axes in signal space</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">signal_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">&lt;BaseSignal, title: , dimensions: (8, 6, 5, 4, 2, 1|9, 7, 3)&gt;</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># A mix of two lists, but specifying all axes explicitly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The order of axes is preserved in both lists</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">navigation_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">signal_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">&lt;BaseSignal, title: , dimensions: (8, 7, 6, 5, 4, 1|9, 3, 2)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.lazy.LazySignal.valuemax">
<code class="descname">valuemax</code><span class="sig-paren">(</span><em>axis</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal.valuemax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the value of coordinates of the maximum along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>axis</strong> (<em>{int | string | axis}</em>) &#8211; The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</li>
<li><strong>out</strong> (<em>{Signal</em><em>, </em><em>None}</em>) &#8211; If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Signal</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p>max, min, sum, mean, std, var, indexmax, amax</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">valuemax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.lazy.LazySignal.valuemin">
<code class="descname">valuemin</code><span class="sig-paren">(</span><em>axis</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.LazySignal.valuemin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the value of coordinates of the minimum along an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>axis</strong> (<em>{int | string | axis}</em>) &#8211; The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</li>
<li><strong>out</strong> (<em>{Signal</em><em>, </em><em>None}</em>) &#8211; If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Signal</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">max()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">min()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">sum()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">mean()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">std()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">var()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">indexmax()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">amax()</span></code></p>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hyperspy._signals.lazy.to_array">
<code class="descclassname">hyperspy._signals.lazy.</code><code class="descname">to_array</code><span class="sig-paren">(</span><em>thing</em>, <em>chunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.lazy.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Accepts BaseSignal, dask or numpy arrays and always produces either
numpy or dask array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>thing</strong> (<em>{BaseSignal</em><em>, </em><em>dask.array.Array</em><em>, </em><em>numpy.ndarray}</em>) &#8211; the thing to be converted</li>
<li><strong>chunks</strong> (<em>{None</em><em>, </em><em>tuple of tuples}</em>) &#8211; If None, the returned value is a numpy array. Otherwise returns dask
array with the chunks as specified.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>res</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">{numpy.ndarray, dask.array.Array}</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.signal1d">
<span id="hyperspy-signals-signal1d-module"></span><h2>hyperspy._signals.signal1d module<a class="headerlink" href="#module-hyperspy._signals.signal1d" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.signal1d.LazySignal1D">
<em class="property">class </em><code class="descclassname">hyperspy._signals.signal1d.</code><code class="descname">LazySignal1D</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.LazySignal1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.lazy.LazySignal" title="hyperspy._signals.lazy.LazySignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.lazy.LazySignal</span></code></a>, <a class="reference internal" href="#hyperspy._signals.signal1d.Signal1D" title="hyperspy._signals.signal1d.Signal1D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.signal1d.Signal1D</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.signal1d.Signal1D">
<em class="property">class </em><code class="descclassname">hyperspy._signals.signal1d.</code><code class="descname">Signal1D</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hyperspy.html#hyperspy.signal.BaseSignal" title="hyperspy.signal.BaseSignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy.signal.BaseSignal</span></code></a>, <a class="reference internal" href="#hyperspy._signals.common_signal1d.CommonSignal1D" title="hyperspy._signals.common_signal1d.CommonSignal1D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.common_signal1d.CommonSignal1D</span></code></a></p>
<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.align1D">
<code class="descname">align1D</code><span class="sig-paren">(</span><em>start=None</em>, <em>end=None</em>, <em>reference_indices=None</em>, <em>max_shift=None</em>, <em>interpolate=True</em>, <em>number_of_interpolation_points=5</em>, <em>interpolation_method='linear'</em>, <em>crop=True</em>, <em>expand=False</em>, <em>fill_value=nan</em>, <em>also_align=None</em>, <em>mask=None</em>, <em>show_progressbar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.align1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the shifts in the signal axis using
cross-correlation and use the estimation to align the data in place.
This method can only estimate the shift by comparing
unidimensional
features that should not change the position.
To decrease memory usage, time of computation and improve
accuracy it is convenient to select the feature of interest
setting the <cite>start</cite> and <cite>end</cite> keywords. By default interpolation is
used to obtain subpixel precision.
:param start, end: The limits of the interval. If int they are taken as the</p>
<blockquote>
<div>axis index. If float they are taken as the axis value.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>reference_indices</strong> (<em>tuple of ints</em><em> or </em><em>None</em>) &#8211; Defines the coordinates of the spectrum that will be used
as eference. If None the spectrum at the current
coordinates is used for this purpose.</li>
<li><strong>max_shift</strong> (<em>int</em>) &#8211; &#8220;Saturation limit&#8221; for the shift.</li>
<li><strong>interpolate</strong> (<em>bool</em>) &#8211; If True, interpolation is used to provide sub-pixel
accuracy.</li>
<li><strong>number_of_interpolation_points</strong> (<em>int</em>) &#8211; Number of interpolation points. Warning: making this number
too big can saturate the memory</li>
<li><strong>interpolation_method</strong> (<em>str</em><em> or </em><em>int</em>) &#8211; Specifies the kind of interpolation as a string (&#8216;linear&#8217;,
&#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic, &#8216;cubic&#8217;) or as an
integer specifying the order of the spline interpolator to
use.</li>
<li><strong>crop</strong> (<em>bool</em>) &#8211; If True automatically crop the signal axis at both ends if
needed.</li>
<li><strong>expand</strong> (<em>bool</em>) &#8211; If True, the data will be expanded to fit all data after alignment.
Overrides <cite>crop</cite>.</li>
<li><strong>fill_value</strong> (<em>float</em>) &#8211; If crop is False fill the data outside of the original
interval with the given value where needed.</li>
<li><strong>also_align</strong> (<em>list of signals</em><em>, </em><em>None</em>) &#8211; A list of BaseSignal instances that has exactly the same
dimensions as this one and that will be aligned using the shift map
estimated using the this signal.</li>
<li><strong>mask</strong> (<em>BaseSignal of bool data type.</em>) &#8211; It must have signal_dimension = 0 and navigation_shape equal to the
current signal. Where mask is True the shift is not computed
and set to nan.</li>
<li><strong>show_progressbar</strong> (<em>None</em><em> or </em><em>bool</em>) &#8211; If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">An array with the result of the estimation. The shift will be</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">SignalDimensionError if the signal dimension is not 1.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.signal1d.Signal1D.estimate_shift1D" title="hyperspy._signals.signal1d.Signal1D.estimate_shift1D"><code class="xref py py-meth docutils literal"><span class="pre">estimate_shift1D()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.calibrate">
<code class="descname">calibrate</code><span class="sig-paren">(</span><em>display=True</em>, <em>toolkit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.calibrate" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calibrate the spectral dimension using a gui.
It displays a window where the new calibration can be set by:
* Setting the offset, units and scale directly
* Selection a range by dragging the mouse on the spectrum figure</p>
<blockquote>
<div>and</div></blockquote>
<p>setting the new values for the given range limits</p>
<p>display: bool</p>
</div></blockquote>
<p>If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</p>
<blockquote>
<div>toolkit: str, iterable of strings or None</div></blockquote>
<p>If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</p>
<blockquote>
<div>For this method to work the output_dimension must be 1. Set the
view
accordingly
Raises
&#8212;&#8212;
SignalDimensionError if the signal dimension is not 1.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.create_model">
<code class="descname">create_model</code><span class="sig-paren">(</span><em>dictionary=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.create_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a model for the current data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>model</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><cite>Model1D</cite> instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.crop_signal1D">
<code class="descname">crop_signal1D</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.crop_signal1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop in place the spectral dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>righ_value</strong> (<em>left_value</em><em>,</em>) &#8211; If int the values are taken as indices. If float they are
converted to indices using the spectral axis calibration.
If left_value is None crops from the beginning of the axis.
If right_value is None crops up to the end of the axis. If
both are
None the interactive cropping interface is activated
enabling
cropping the spectrum using a span selector in the signal
plot.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">SignalDimensionError if the signal dimension is not 1.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.estimate_peak_width">
<code class="descname">estimate_peak_width</code><span class="sig-paren">(</span><em>factor=0.5</em>, <em>window=None</em>, <em>return_interval=False</em>, <em>parallel=None</em>, <em>show_progressbar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.estimate_peak_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the width of the highest intensity of peak
of the spectra at a given fraction of its maximum.</p>
<p>It can be used with asymmetric peaks. For accurate results any
background must be previously substracted.
The estimation is performed by interpolation using cubic splines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>factor</strong> (<em>0 &lt; float &lt; 1</em>) &#8211; The default, 0.5, estimates the FWHM.</li>
<li><strong>window</strong> (<em>None</em><em>, </em><em>float</em>) &#8211; The size of the window centred at the peak maximum
used to perform the estimation.
The window size must be chosen with care: if it is narrower
than the width of the peak at some positions or if it is
so wide that it includes other more intense peaks this
method cannot compute the width and a NaN is stored instead.</li>
<li><strong>return_interval</strong> (<em>bool</em>) &#8211; If True, returns 2 extra signals with the positions of the
desired height fraction at the left and right of the
peak.</li>
<li><strong>parallel</strong> (<em>{None</em><em>, </em><em>bool}</em>) &#8211; </li>
<li><strong>show_progressbar</strong> (<em>None</em><em> or </em><em>bool</em>) &#8211; If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><em>width or [width, left, right], depending on the value of</em></li>
<li><cite>return_interval</cite>.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.estimate_shift1D">
<code class="descname">estimate_shift1D</code><span class="sig-paren">(</span><em>start=None</em>, <em>end=None</em>, <em>reference_indices=None</em>, <em>max_shift=None</em>, <em>interpolate=True</em>, <em>number_of_interpolation_points=5</em>, <em>mask=None</em>, <em>parallel=None</em>, <em>show_progressbar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.estimate_shift1D" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Estimate the shifts in the current signal axis using</dt>
<dd>cross-correlation.</dd>
</dl>
<p>This method can only estimate the shift by comparing
unidimensional features that should not change the position in
the signal axis. To decrease the memory usage, the time of
computation and the accuracy of the results it is convenient to
select the feature of interest providing sensible values for
<cite>start</cite> and <cite>end</cite>. By default interpolation is used to obtain
subpixel precision.
:param start, end: The limits of the interval. If int they are taken as the</p>
<blockquote>
<div>axis index. If float they are taken as the axis value.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>reference_indices</strong> (<em>tuple of ints</em><em> or </em><em>None</em>) &#8211; Defines the coordinates of the spectrum that will be used
as eference. If None the spectrum at the current
coordinates is used for this purpose.</li>
<li><strong>max_shift</strong> (<em>int</em>) &#8211; &#8220;Saturation limit&#8221; for the shift.</li>
<li><strong>interpolate</strong> (<em>bool</em>) &#8211; If True, interpolation is used to provide sub-pixel
accuracy.</li>
<li><strong>number_of_interpolation_points</strong> (<em>int</em>) &#8211; Number of interpolation points. Warning: making this number
too big can saturate the memory</li>
<li><strong>mask</strong> (<em>BaseSignal of bool data type.</em>) &#8211; It must have signal_dimension = 0 and navigation_shape equal to the
current signal. Where mask is True the shift is not computed
and set to nan.</li>
<li><strong>parallel</strong> (<em>{None</em><em>, </em><em>bool}</em>) &#8211; </li>
<li><strong>show_progressbar</strong> (<em>None</em><em> or </em><em>bool</em>) &#8211; If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">An array with the result of the estimation in the axis units.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">SignalDimensionError if the signal dimension is not 1.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.filter_butterworth">
<code class="descname">filter_butterworth</code><span class="sig-paren">(</span><em>cutoff_frequency_ratio=None</em>, <em>type='low'</em>, <em>order=2</em>, <em>display=True</em>, <em>toolkit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.filter_butterworth" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Butterworth filter in place.</p>
<p>display: bool</p>
</div></blockquote>
<p>If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</p>
<blockquote>
<div>toolkit: str, iterable of strings or None</div></blockquote>
<p>If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</p>
<blockquote>
<div>SignalDimensionError if the signal dimension is not 1.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.find_peaks1D_ohaver">
<code class="descname">find_peaks1D_ohaver</code><span class="sig-paren">(</span><em>xdim=None</em>, <em>slope_thresh=0</em>, <em>amp_thresh=None</em>, <em>subchannel=True</em>, <em>medfilt_radius=5</em>, <em>maxpeakn=30000</em>, <em>peakgroup=10</em>, <em>parallel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.find_peaks1D_ohaver" title="Permalink to this definition">¶</a></dt>
<dd><p>Find peaks along a 1D line (peaks in spectrum/spectra).</p>
<p>Function to locate the positive peaks in a noisy x-y data set.</p>
<p>Detects peaks by looking for downward zero-crossings in the
first derivative that exceed &#8216;slope_thresh&#8217;.</p>
<p>Returns an array containing position, height, and width of each
peak.</p>
<p>&#8216;slope_thresh&#8217; and &#8216;amp_thresh&#8217;, control sensitivity: higher
values will
neglect smaller features.</p>
<p>peakgroup is the number of points around the top peak to search
around</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>slope_thresh</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) &#8211; 1st derivative threshold to count the peak
default is set to 0.5
higher values will neglect smaller features.</li>
<li><strong>amp_thresh</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) &#8211; intensity threshold above which
default is set to 10% of max(y)
higher values will neglect smaller features.</li>
<li><strong>medfilt_radius</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) &#8211; median filter window to apply to smooth the data
(see scipy.signal.medfilt)
if 0, no filter will be applied.
default is set to 5</li>
<li><strong>peakgroup</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) &#8211; number of points around the &#8220;top part&#8221; of the peak
default is set to 10</li>
<li><strong>maxpeakn</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) &#8211; number of maximum detectable peaks
default is set to 5000</li>
<li><strong>subpix</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) &#8211; default is set to True</li>
<li><strong>parallel</strong> (<em>{None</em><em>, </em><em>bool}</em>) &#8211; Perform the operation in a threaded (parallel) manner.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><strong>peaks</strong> (<em>structured array of shape _navigation_shape_in_array in which</em>)</li>
<li><em>each cell contains an array that contains as many structured arrays as</em></li>
<li><strong>peaks where found at that location and which fields</strong> (<em>position, height,</em>)</li>
<li><em>width, contains position, height, and width of each peak.</em></li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">SignalDimensionError if the signal dimension is not 1.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.gaussian_filter">
<code class="descname">gaussian_filter</code><span class="sig-paren">(</span><em>FWHM</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.gaussian_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a Gaussian filter in the spectral dimension in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>FWHM</strong> (<em>float</em>) &#8211; The Full Width at Half Maximum of the gaussian in the
spectral axis units</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>ValueError if FWHM is equal or less than zero.</li>
<li>SignalDimensionError if the signal dimension is not 1.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.hanning_taper">
<code class="descname">hanning_taper</code><span class="sig-paren">(</span><em>side='both'</em>, <em>channels=None</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.hanning_taper" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a hanning taper to the data in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>side</strong> (<em>{'left'</em><em>, </em><em>'right'</em><em>, </em><em>'both'}</em>) &#8211; </li>
<li><strong>channels</strong> (<em>{None</em><em>, </em><em>int}</em>) &#8211; The number of channels to taper. If None 5% of the total
number of channels are tapered.</li>
<li><strong>offset</strong> (<em>int</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">channels</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">SignalDimensionError if the signal dimension is not 1.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.integrate_in_range">
<code class="descname">integrate_in_range</code><span class="sig-paren">(</span><em>signal_range='interactive'</em>, <em>display=True</em>, <em>toolkit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.integrate_in_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Sums the spectrum over an energy range, giving the integrated
area.
The energy range can either be selected through a GUI or the command
line.
:param signal_range: l and r are the left and right limits of the range. They can be</p>
<blockquote>
<div>numbers or None, where None indicates the extremes of the interval.
If l and r are floats the <cite>signal_range</cite> will be in axis units (for
example eV). If l and r are integers the <cite>signal_range</cite> will be in
index units. When <cite>signal_range</cite> is &#8220;interactive&#8221; (default) the
range is selected using a GUI.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>integrated_spectrum</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">BaseSignal subclass</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">integrate_simpson()</span></code></p>
</div>
<p class="rubric">Examples</p>
<p>Using the GUI
&gt;&gt;&gt; s = hs.signals.Signal1D(range(1000))
&gt;&gt;&gt; s.integrate_in_range() #doctest: +SKIP</p>
<p>Using the CLI
&gt;&gt;&gt; s_int = s.integrate_in_range(signal_range=(560,None))</p>
<p>Selecting a range in the axis units, by specifying the
signal range with floats.
&gt;&gt;&gt; s_int = s.integrate_in_range(signal_range=(560.,590.))</p>
<p>Selecting a range using the index, by specifying the
signal range with integers.
&gt;&gt;&gt; s_int = s.integrate_in_range(signal_range=(100,120))</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.interpolate_in_between">
<code class="descname">interpolate_in_between</code><span class="sig-paren">(</span><em>start</em>, <em>end</em>, <em>delta=3</em>, <em>parallel=None</em>, <em>show_progressbar=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.interpolate_in_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the data in a given range by interpolation.
The operation is performed in place.
:param start, end: The limits of the interval. If int they are taken as the</p>
<blockquote>
<div>axis index. If float they are taken as the axis value.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>delta</strong> (<em>{int | float}</em>) &#8211; The windows around the (start, end) to use for interpolation</li>
<li><strong>show_progressbar</strong> (<em>None</em><em> or </em><em>bool</em>) &#8211; If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</li>
<li><strong>parallel</strong> (<em>{None</em><em>, </em><em>bool}</em>) &#8211; </li>
<li><strong>extra keyword arguments are passed to</strong> (<em>All</em>) &#8211; </li>
<li><strong>See the function documentation</strong> (<em>scipy.interpolate.interp1d.</em>) &#8211; </li>
<li><strong>details.</strong> (<em>for</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">SignalDimensionError if the signal dimension is not 1.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.remove_background">
<code class="descname">remove_background</code><span class="sig-paren">(</span><em>signal_range='interactive'</em>, <em>background_type='PowerLaw'</em>, <em>polynomial_order=2</em>, <em>fast=True</em>, <em>show_progressbar=None</em>, <em>display=True</em>, <em>toolkit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.remove_background" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Remove the background, either in place using a gui or returned as a new
spectrum using the command line.
Parameters
&#8212;&#8212;&#8212;-
signal_range : tuple, optional</p>
<blockquote>
<div>If this argument is not specified, the signal range has to be
selected using a GUI. And the original spectrum will be replaced.
If tuple is given, the a spectrum will be returned.</div></blockquote>
<dl class="docutils">
<dt>background_type <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The type of component which should be used to fit the background.
Possible components: PowerLaw, Gaussian, Offset, Polynomial
If Polynomial is used, the polynomial order can be specified</dd>
<dt>polynomial_order <span class="classifier-delimiter">:</span> <span class="classifier">int, default 2</span></dt>
<dd>Specify the polynomial order if a Polynomial background is used.</dd>
<dt>fast <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, perform an approximative estimation of the parameters.
If False, the signal is fitted using non-linear least squares
afterwards.This is slower compared to the estimation but
possibly more accurate.</dd>
<dt>show_progressbar <span class="classifier-delimiter">:</span> <span class="classifier">None or bool</span></dt>
<dd>If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</dd>
</dl>
<p>display: bool</p>
</div></blockquote>
<p>If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</p>
<blockquote>
<div>toolkit: str, iterable of strings or None</div></blockquote>
<p>If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</p>
<blockquote>
<div><p>Using gui, replaces spectrum s
&gt;&gt;&gt; s = hs.signals.Signal1D(range(1000))
&gt;&gt;&gt; s.remove_background() #doctest: +SKIP</p>
<p>Using command line, returns a spectrum
&gt;&gt;&gt; s1 = s.remove_background(signal_range=(400,450), background_type=&#8217;PowerLaw&#8217;)</p>
<p>Using a full model to fit the background
&gt;&gt;&gt; s1 = s.remove_background(signal_range=(400,450), fast=False)</p>
<p>SignalDimensionError if the signal dimension is not 1.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.shift1D">
<code class="descname">shift1D</code><span class="sig-paren">(</span><em>shift_array</em>, <em>interpolation_method='linear'</em>, <em>crop=True</em>, <em>expand=False</em>, <em>fill_value=nan</em>, <em>parallel=None</em>, <em>show_progressbar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.shift1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the data in place over the signal axis by the amount specified
by an array.
:param shift_array: An array containing the shifting amount. It must have</p>
<blockquote>
<div><cite>axes_manager._navigation_shape_in_array</cite> shape.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>interpolation_method</strong> (<em>str</em><em> or </em><em>int</em>) &#8211; Specifies the kind of interpolation as a string (&#8216;linear&#8217;,
&#8216;nearest&#8217;, &#8216;zero&#8217;, &#8216;slinear&#8217;, &#8216;quadratic, &#8216;cubic&#8217;) or as an
integer specifying the order of the spline interpolator to
use.</li>
<li><strong>crop</strong> (<em>bool</em>) &#8211; If True automatically crop the signal axis at both ends if
needed.</li>
<li><strong>expand</strong> (<em>bool</em>) &#8211; If True, the data will be expanded to fit all data after alignment.
Overrides <cite>crop</cite>.</li>
<li><strong>fill_value</strong> (<em>float</em>) &#8211; If crop is False fill the data outside of the original
interval with the given value where needed.</li>
<li><strong>parallel</strong> (<em>{None</em><em>, </em><em>bool}</em>) &#8211; </li>
<li><strong>show_progressbar</strong> (<em>None</em><em> or </em><em>bool</em>) &#8211; If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">SignalDimensionError if the signal dimension is not 1.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.smooth_lowess">
<code class="descname">smooth_lowess</code><span class="sig-paren">(</span><em>smoothing_parameter=None</em>, <em>number_of_iterations=None</em>, <em>show_progressbar=None</em>, <em>parallel=None</em>, <em>display=True</em>, <em>toolkit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.smooth_lowess" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Lowess data smoothing in place.
If <cite>smoothing_parameter</cite> or <cite>number_of_iterations</cite> are None the method
is run in interactive mode.
Parameters
&#8212;&#8212;&#8212;-
smoothing_parameter: float or None</p>
<blockquote>
<div>Between 0 and 1. The fraction of the data used
when estimating each y-value.</div></blockquote>
<dl class="docutils">
<dt>number_of_iterations: int or None</dt>
<dd>The number of residual-based reweightings
to perform.</dd>
<dt>show_progressbar <span class="classifier-delimiter">:</span> <span class="classifier">None or bool</span></dt>
<dd>If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</dd>
<dt>parallel <span class="classifier-delimiter">:</span> <span class="classifier">{Bool, None, int}</span></dt>
<dd>Perform the operation parallel</dd>
</dl>
<p>display: bool</p>
</div></blockquote>
<p>If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</p>
<blockquote>
<div>toolkit: str, iterable of strings or None</div></blockquote>
<p>If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</p>
<blockquote>
<div>SignalDimensionError if the signal dimension is not 1.
ImportError if statsmodels is not installed.
Notes
&#8212;&#8211;
This method uses the lowess algorithm from statsmodels. statsmodels
is required for this method.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.smooth_savitzky_golay">
<code class="descname">smooth_savitzky_golay</code><span class="sig-paren">(</span><em>polynomial_order=None</em>, <em>window_length=None</em>, <em>differential_order=0</em>, <em>parallel=None</em>, <em>display=True</em>, <em>toolkit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.smooth_savitzky_golay" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Apply a Savitzky-Golay filter to the data in place.
If <cite>polynomial_order</cite> or <cite>window_length</cite> or <cite>differential_order</cite> are
None the method is run in interactive mode.
Parameters
&#8212;&#8212;&#8212;-
window_length : int</p>
<blockquote>
<div>The length of the filter window (i.e. the number of coefficients).
<cite>window_length</cite> must be a positive odd integer.</div></blockquote>
<dl class="docutils">
<dt>polynomial_order <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The order of the polynomial used to fit the samples.
<cite>polyorder</cite> must be less than <cite>window_length</cite>.</dd>
<dt>differential_order: int, optional</dt>
<dd>The order of the derivative to compute.  This must be a
nonnegative integer.  The default is 0, which means to filter
the data without differentiating.</dd>
<dt>parallel <span class="classifier-delimiter">:</span> <span class="classifier">{bool, None}</span></dt>
<dd>Perform the operation in a threaded manner (parallely).</dd>
</dl>
<p>display: bool</p>
</div></blockquote>
<p>If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</p>
<blockquote>
<div>toolkit: str, iterable of strings or None</div></blockquote>
<p>If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</p>
<blockquote>
<div>More information about the filter in <cite>scipy.signal.savgol_filter</cite>.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.smooth_tv">
<code class="descname">smooth_tv</code><span class="sig-paren">(</span><em>smoothing_parameter=None</em>, <em>show_progressbar=None</em>, <em>parallel=None</em>, <em>display=True</em>, <em>toolkit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.smooth_tv" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Total variation data smoothing in place.
Parameters
&#8212;&#8212;&#8212;-
smoothing_parameter: float or None</p>
<blockquote>
<div>Denoising weight relative to L2 minimization. If None the method
is run in interactive mode.</div></blockquote>
<dl class="docutils">
<dt>show_progressbar <span class="classifier-delimiter">:</span> <span class="classifier">None or bool</span></dt>
<dd>If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</dd>
<dt>parallel <span class="classifier-delimiter">:</span> <span class="classifier">{Bool, None, int}</span></dt>
<dd>Perform the operation parallely</dd>
</dl>
<p>display: bool</p>
</div></blockquote>
<p>If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</p>
<blockquote>
<div>toolkit: str, iterable of strings or None</div></blockquote>
<p>If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</p>
<blockquote>
<div>SignalDimensionError if the signal dimension is not 1.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal1d.Signal1D.spikes_removal_tool">
<code class="descname">spikes_removal_tool</code><span class="sig-paren">(</span><em>signal_mask=None</em>, <em>navigation_mask=None</em>, <em>display=True</em>, <em>toolkit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.Signal1D.spikes_removal_tool" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphical interface to remove spikes from EELS spectra.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>signal_mask</strong> (<em>boolean array</em>) &#8211; Restricts the operation to the signal locations not marked
as True (masked)</li>
<li><strong>navigation_mask</strong> (<em>boolean array</em>) &#8211; Restricts the operation to the navigation locations not
marked as True (masked)</li>
<li><strong>display</strong> (<em>bool</em>) &#8211; If True, display the user interface widgets. If False, return the widgets
container in a dictionary, usually for customisation or testing.</li>
<li><strong>toolkit</strong> (<em>str</em><em>, </em><em>iterable of strings</em><em> or </em><em>None</em>) &#8211; If None (default), all available widgets are displayed or returned. If
string, only the widgets of the selected toolkit are displayed if available.
If an interable of toolkit strings, the widgets of all listed toolkits are
displayed or returned.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">_spikes_diagnosis()</span></code></p>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hyperspy._signals.signal1d.find_peaks_ohaver">
<code class="descclassname">hyperspy._signals.signal1d.</code><code class="descname">find_peaks_ohaver</code><span class="sig-paren">(</span><em>y</em>, <em>x=None</em>, <em>slope_thresh=0.0</em>, <em>amp_thresh=None</em>, <em>medfilt_radius=5</em>, <em>maxpeakn=30000</em>, <em>peakgroup=10</em>, <em>subchannel=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.find_peaks_ohaver" title="Permalink to this definition">¶</a></dt>
<dd><p>Find peaks along a 1D line.
Function to locate the positive peaks in a noisy x-y data set.
Detects peaks by looking for downward zero-crossings in the first
derivative that exceed &#8216;slope_thresh&#8217;.
Returns an array containing position, height, and width of each peak.
Sorted by position.
&#8216;slope_thresh&#8217; and &#8216;amp_thresh&#8217;, control sensitivity: higher values will
neglect smaller features.
:param y: 1D input array, e.g. a spectrum
:type y: array
:param x: 1D array describing the calibration of y (must have same shape as y)
:type x: array (optional)
:param slope_thresh: 1st derivative threshold to count the peak</p>
<blockquote>
<div>default is set to 0.5
higher values will neglect smaller features.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>amp_thresh</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) &#8211; intensity threshold above which
default is set to 10% of max(y)
higher values will neglect smaller features.</li>
<li><strong>medfilt_radius</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) &#8211; median filter window to apply to smooth the data
(see scipy.signal.medfilt)
if 0, no filter will be applied.
default is set to 5</li>
<li><strong>peakgroup</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) &#8211; number of points around the &#8220;top part&#8221; of the peak
default is set to 10</li>
<li><strong>maxpeakn</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) &#8211; number of maximum detectable peaks
default is set to 30000</li>
<li><strong>subchannel</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) &#8211; default is set to True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>P</strong> &#8211; contains position, height, and width of each peak</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">structured array of shape (npeaks) and fields: position, <a class="reference internal" href="hyperspy.html#hyperspy.roi.RectangularROI.width" title="hyperspy.roi.RectangularROI.width">width</a>, <a class="reference internal" href="hyperspy.html#hyperspy.roi.RectangularROI.height" title="hyperspy.roi.RectangularROI.height">height</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peaks</span> <span class="o">=</span> <span class="n">find_peaks_ohaver</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Original code from T. C. O&#8217;Haver, 1995.
Version 2  Last revised Oct 27, 2006 Converted to Python by
Michael Sarahan, Feb 2011.
Revised to handle edges better.  MCS, Mar 2011</p>
</dd></dl>

<dl class="function">
<dt id="hyperspy._signals.signal1d.interpolate1D">
<code class="descclassname">hyperspy._signals.signal1d.</code><code class="descname">interpolate1D</code><span class="sig-paren">(</span><em>number_of_interpolation_points</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal1d.interpolate1D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.signal2d">
<span id="hyperspy-signals-signal2d-module"></span><h2>hyperspy._signals.signal2d module<a class="headerlink" href="#module-hyperspy._signals.signal2d" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.signal2d.LazySignal2D">
<em class="property">class </em><code class="descclassname">hyperspy._signals.signal2d.</code><code class="descname">LazySignal2D</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.LazySignal2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.lazy.LazySignal" title="hyperspy._signals.lazy.LazySignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.lazy.LazySignal</span></code></a>, <a class="reference internal" href="#hyperspy._signals.signal2d.Signal2D" title="hyperspy._signals.signal2d.Signal2D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.signal2d.Signal2D</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="hyperspy._signals.signal2d.Signal2D">
<em class="property">class </em><code class="descclassname">hyperspy._signals.signal2d.</code><code class="descname">Signal2D</code><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.Signal2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hyperspy.html#hyperspy.signal.BaseSignal" title="hyperspy.signal.BaseSignal"><code class="xref py py-class docutils literal"><span class="pre">hyperspy.signal.BaseSignal</span></code></a>, <a class="reference internal" href="#hyperspy._signals.common_signal2d.CommonSignal2D" title="hyperspy._signals.common_signal2d.CommonSignal2D"><code class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.common_signal2d.CommonSignal2D</span></code></a></p>
<dl class="method">
<dt id="hyperspy._signals.signal2d.Signal2D.add_ramp">
<code class="descname">add_ramp</code><span class="sig-paren">(</span><em>ramp_x</em>, <em>ramp_y</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.Signal2D.add_ramp" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a linear ramp to the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ramp_x</strong> (<em>float</em>) &#8211; Slope of the ramp in x-direction.</li>
<li><strong>ramp_y</strong> (<em>float</em>) &#8211; Slope of the ramp in y-direction.</li>
<li><strong>offset</strong> (<em>float</em><em>, </em><em>optional</em>) &#8211; Offset of the ramp at the signal fulcrum.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The fulcrum of the linear ramp is at the origin and the slopes are given in units of
the axis with the according scale taken into account. Both are available via the
<cite>axes_manager</cite> of the signal.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal2d.Signal2D.align2D">
<code class="descname">align2D</code><span class="sig-paren">(</span><em>crop=True</em>, <em>fill_value=nan</em>, <em>shifts=None</em>, <em>expand=False</em>, <em>roi=None</em>, <em>sobel=True</em>, <em>medfilter=True</em>, <em>hanning=True</em>, <em>plot=False</em>, <em>normalize_corr=False</em>, <em>reference='current'</em>, <em>dtype='float'</em>, <em>correlation_threshold=None</em>, <em>chunk_size=30</em>, <em>interpolation_order=1</em>, <em>show_progressbar=None</em>, <em>parallel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.Signal2D.align2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Align the images in place using user provided shifts or by
estimating the shifts.
Please, see <cite>estimate_shift2D</cite> docstring for details
on the rest of the parameters not documented in the following
section
:param crop: If True, the data will be cropped not to include regions</p>
<blockquote>
<div>with missing data</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fill_value</strong> (<em>int</em><em>, </em><em>float</em><em>, </em><em>nan</em>) &#8211; The areas with missing data are filled with the given value.
Default is nan.</li>
<li><strong>shifts</strong> (<em>None</em><em> or </em><em>list of tuples</em>) &#8211; If None the shifts are estimated using
<cite>estimate_shift2D</cite>.</li>
<li><strong>expand</strong> (<em>bool</em>) &#8211; If True, the data will be expanded to fit all data after alignment.
Overrides <cite>crop</cite>.</li>
<li><strong>interpolation_order</strong> (<em>int</em><em>, </em><em>default 1.</em>) &#8211; The order of the spline interpolation. Default is 1, linear
interpolation.</li>
<li><strong>parallel</strong> (<em>{None</em><em>, </em><em>bool}</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>shifts</strong> &#8211; The shifts are returned only if <cite>shifts</cite> is None</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The statistical analysis approach to the translation estimation
when using <a href="#id21"><span class="problematic" id="id22">`</span></a>reference`=&#8217;stat&#8217; roughly follows <a href="#id31"><span class="problematic" id="id32"><span id="id23"></span>[1]_</span></a> . If you use
it please cite their article.</p>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Schaffer, Bernhard, Werner Grogger, and Gerald</td></tr>
</tbody>
</table>
<p>Kothleitner. “Automated Spatial Drift Correction for EFTEM
Signal2D Series.”
Ultramicroscopy 102, no. 1 (December 2004): 27–36.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal2d.Signal2D.create_model">
<code class="descname">create_model</code><span class="sig-paren">(</span><em>dictionary=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.Signal2D.create_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a model for the current signal
:param dictionary: A dictionary to be used to recreate a model. Usually generated using</p>
<blockquote>
<div><code class="xref py py-meth docutils literal"><span class="pre">hyperspy.model.as_dictionary()</span></code></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">A Model class</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal2d.Signal2D.crop_image">
<code class="descname">crop_image</code><span class="sig-paren">(</span><em>top=None</em>, <em>bottom=None</em>, <em>left=None</em>, <em>right=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.Signal2D.crop_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Crops an image in place.</p>
<p>top, bottom, left, right : int or float</p>
<blockquote>
<div>If int the values are taken as indices. If float the values are
converted to indices.</div></blockquote>
<p>crop</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal2d.Signal2D.estimate_shift2D">
<code class="descname">estimate_shift2D</code><span class="sig-paren">(</span><em>reference='current'</em>, <em>correlation_threshold=None</em>, <em>chunk_size=30</em>, <em>roi=None</em>, <em>normalize_corr=False</em>, <em>sobel=True</em>, <em>medfilter=True</em>, <em>hanning=True</em>, <em>plot=False</em>, <em>dtype='float'</em>, <em>show_progressbar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.Signal2D.estimate_shift2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the shifts in a image using phase correlation
This method can only estimate the shift by comparing
bidimensional features that should not change position
between frames. To decrease the memory usage, the time of
computation and the accuracy of the results it is convenient
to select a region of interest by setting the roi keyword.
:param reference: If &#8216;current&#8217; (default) the image at the current</p>
<blockquote>
<div>coordinates is taken as reference. If &#8216;cascade&#8217; each image
is aligned with the previous one. If &#8216;stat&#8217; the translation
of every image with all the rest is estimated and by
performing statistical analysis on the result the
translation is estimated.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>correlation_threshold</strong> (<em>{None</em><em>, </em><em>'auto'</em><em>, </em><em>float}</em>) &#8211; This parameter is only relevant when <cite>reference</cite> is &#8216;stat&#8217;.
If float, the shift estimations with a maximum correlation
value lower than the given value are not used to compute
the estimated shifts. If &#8216;auto&#8217; the threshold is calculated
automatically as the minimum maximum correlation value
of the automatically selected reference image.</li>
<li><strong>chunk_size</strong> (<em>{None</em><em>, </em><em>int}</em>) &#8211; If int and <a href="#id25"><span class="problematic" id="id26">`</span></a>reference`==&#8217;stat&#8217; the number of images used
as reference are limited to the given value.</li>
<li><strong>roi</strong> (<em>tuple of ints</em><em> or </em><em>floats</em><em> (</em><em>left</em><em>, </em><em>right</em><em>, </em><em>top bottom</em><em>)</em>) &#8211; Define the region of interest. If int(float) the position
is given axis index(value).</li>
<li><strong>sobel</strong> (<em>bool</em>) &#8211; apply a sobel filter for edge enhancement</li>
<li><strong>medfilter</strong> (<em>bool</em>) &#8211; apply a median filter for noise reduction</li>
<li><strong>hanning</strong> (<em>bool</em>) &#8211; Apply a 2d hanning filter</li>
<li><strong>plot</strong> (<em>bool</em><em> or </em><em>&quot;reuse&quot;</em>) &#8211; If True plots the images after applying the filters and
the phase correlation. If &#8216;reuse&#8217;, it will also plot the images,
but it will only use one figure, and continously update the images
in that figure as it progresses through the stack.</li>
<li><strong>dtype</strong> (<em>str</em><em> or </em><a class="reference internal" href="hyperspy.io_plugins.html#hyperspy.io_plugins.digital_micrograph.ImageObject.dtype" title="hyperspy.io_plugins.digital_micrograph.ImageObject.dtype"><em>dtype</em></a>) &#8211; Typecode or data-type in which the calculations must be
performed.</li>
<li><strong>show_progressbar</strong> (<em>None</em><em> or </em><em>bool</em>) &#8211; If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of applied shifts</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The statistical analysis approach to the translation estimation
when using <a href="#id27"><span class="problematic" id="id28">`</span></a>reference`=&#8217;stat&#8217; roughly follows <a href="#id33"><span class="problematic" id="id34"><span id="id29"></span>[1]_</span></a> . If you use
it please cite their article.</p>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Schaffer, Bernhard, Werner Grogger, and Gerald</td></tr>
</tbody>
</table>
<p>Kothleitner. “Automated Spatial Drift Correction for EFTEM
Signal2D Series.”
Ultramicroscopy 102, no. 1 (December 2004): 27–36.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.signal2d.Signal2D.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>colorbar=True</em>, <em>scalebar=True</em>, <em>scalebar_color='white'</em>, <em>axes_ticks=None</em>, <em>saturated_pixels=0</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>no_nans=False</em>, <em>centre_colormap='auto'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.Signal2D.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the signal at the current coordinates.</p>
<p>For multidimensional datasets an optional figure,
the &#8220;navigator&#8221;, with a cursor to navigate that data is
raised. In any case it is possible to navigate the data using
the sliders. Currently only signals with signal_dimension equal to
0, 1 and 2 can be plotted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>navigator</strong> (<em>{&quot;auto&quot;</em><em>, </em><em>None</em><em>, </em><em>&quot;slider&quot;</em><em>, </em><em>&quot;spectrum&quot;</em><em>, </em><em>Signal}</em>) &#8211; If &#8220;auto&#8221;, if navigation_dimension &gt; 0, a navigator is
provided to explore the data.
If navigation_dimension is 1 and the signal is an image
the navigator is a spectrum obtained by integrating
over the signal axes (the image).
If navigation_dimension is 1 and the signal is a spectrum
the navigator is an image obtained by stacking horizontally
all the spectra in the dataset.
If navigation_dimension is &gt; 1, the navigator is an image
obtained by integrating the data over the signal axes.
Additionaly, if navigation_dimension &gt; 2 a window
with one slider per axis is raised to navigate the data.
For example,
if the dataset consists of 3 navigation axes X, Y, Z and one
signal axis, E, the default navigator will be an image
obtained by integrating the data over E at the current Z
index and a window with sliders for the X, Y and Z axes
will be raised. Notice that changing the Z-axis index
changes the navigator in this case.
If &#8220;slider&#8221; and the navigation dimension &gt; 0 a window
with one slider per axis is raised to navigate the data.
If &#8220;spectrum&#8221; and navigation_dimension &gt; 0 the navigator
is always a spectrum obtained by integrating the data
over all other axes.
If None, no navigator will be provided.
Alternatively a Signal instance can be provided. The signal
dimension must be 1 (for a spectrum navigator) or 2 (for a
image navigator) and navigation_shape must be 0 (for a static
navigator) or navigation_shape + signal_shape must be equal
to the navigator_shape of the current object (for a dynamic
navigator).
If the signal dtype is RGB or RGBA this parameters has no
effect and is always &#8220;slider&#8221;.</li>
<li><strong>axes_manager</strong> (<em>{None</em><em>, </em><em>axes_manager}</em>) &#8211; If None <cite>axes_manager</cite> is used.</li>
<li><strong>plot_markers</strong> (<em>bool</em><em>, </em><em>default True</em>) &#8211; Plot markers added using s.add_marker(marker, permanent=True).
Note, a large number of markers might lead to very slow plotting.</li>
<li><strong>colorbar</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; If true, a colorbar is plotted for non-RGB images.</li>
<li><strong>scalebar</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; If True and the units and scale of the x and y axes are the same a
scale bar is plotted.</li>
<li><strong>scalebar_color</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; A valid MPL color string; will be used as the scalebar color.</li>
<li><strong>axes_ticks</strong> (<em>{None</em><em>, </em><em>bool}</em><em>, </em><em>optional</em>) &#8211; If True, plot the axes ticks. If None axes_ticks are only
plotted when the scale bar is not plotted. If False the axes ticks
are never plotted.</li>
<li><strong>saturated_pixels</strong> (<em>scalar</em>) &#8211; The percentage of pixels that are left out of the bounds.
For example, the low and high bounds of a value of 1 are the 0.5%
and 99.5% percentiles. It must be in the [0, 100] range.</li>
<li><strong>vmax</strong> (<a class="reference internal" href="hyperspy.drawing.html#hyperspy.drawing.image.ImagePlot.vmin" title="hyperspy.drawing.image.ImagePlot.vmin"><em>vmin</em></a><em>,</em>) &#8211; <cite>vmin</cite> and <cite>vmax</cite> are used to normalize luminance data.</li>
<li><strong>no_nans</strong> (<em>bool</em><em>, </em><em>optional</em>) &#8211; If True, set nans to zero for plotting.</li>
<li><strong>centre_colormap</strong> (<em>{&quot;auto&quot;</em><em>, </em><em>True</em><em>, </em><em>False}</em>) &#8211; If True the centre of the color scheme is set to zero. This is
specially useful when using diverging color schemes. If &#8220;auto&#8221;
(default), diverging color schemes are automatically centred.</li>
<li><strong>optional</strong> (<em>**kwargs</em><em>,</em>) &#8211; Additional key word arguments passed to matplotlib.imshow()</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="hyperspy._signals.signal2d.estimate_image_shift">
<code class="descclassname">hyperspy._signals.signal2d.</code><code class="descname">estimate_image_shift</code><span class="sig-paren">(</span><em>ref</em>, <em>image</em>, <em>roi=None</em>, <em>sobel=True</em>, <em>medfilter=True</em>, <em>hanning=True</em>, <em>plot=False</em>, <em>dtype='float'</em>, <em>normalize_corr=False</em>, <em>return_maxval=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.estimate_image_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the shift in a image using phase correlation</p>
<p>This method can only estimate the shift by comparing
bidimensional features that should not change the position
in the given axis. To decrease the memory usage, the time of
computation and the accuracy of the results it is convenient
to select a region of interest by setting the roi keyword.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>roi</strong> (<em>tuple of ints</em><em> (</em><em>top</em><em>, </em><em>bottom</em><em>, </em><em>left</em><em>, </em><em>right</em><em>)</em>) &#8211; Define the region of interest</li>
<li><strong>sobel</strong> (<em>bool</em>) &#8211; apply a sobel filter for edge enhancement</li>
<li><strong>medfilter</strong> (<em>bool</em>) &#8211; apply a median filter for noise reduction</li>
<li><strong>hanning</strong> (<em>bool</em>) &#8211; Apply a 2d hanning filter</li>
<li><strong>plot</strong> (<em>bool | matplotlib.Figure</em>) &#8211; If True, plots the images after applying the filters and the phase
correlation. If a figure instance, the images will be plotted to the
given figure.</li>
<li><strong>reference</strong> (<em>'current' | 'cascade'</em>) &#8211; If &#8216;current&#8217; (default) the image at the current
coordinates is taken as reference. If &#8216;cascade&#8217; each image
is aligned with the previous one.</li>
<li><strong>dtype</strong> (<em>str</em><em> or </em><a class="reference internal" href="hyperspy.io_plugins.html#hyperspy.io_plugins.digital_micrograph.ImageObject.dtype" title="hyperspy.io_plugins.digital_micrograph.ImageObject.dtype"><em>dtype</em></a>) &#8211; Typecode or data-type in which the calculations must be
performed.</li>
<li><strong>normalize_corr</strong> (<em>bool</em>) &#8211; If True use phase correlation instead of standard correlation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>shifts</strong> (<em>np.array</em>) &#8211; containing the estimate shifts</li>
<li><strong>max_value</strong> (<em>float</em>) &#8211; The maximum value of the correlation</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hyperspy._signals.signal2d.fft_correlation">
<code class="descclassname">hyperspy._signals.signal2d.</code><code class="descname">fft_correlation</code><span class="sig-paren">(</span><em>in1</em>, <em>in2</em>, <em>normalize=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.fft_correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Correlation of two N-dimensional arrays using FFT.</p>
<p>Adapted from scipy&#8217;s fftconvolve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>in2</strong> (<em>in1</em><em>,</em>) &#8211; </li>
<li><strong>normalize</strong> (<em>bool</em>) &#8211; If True performs phase correlation</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="hyperspy._signals.signal2d.hanning2d">
<code class="descclassname">hyperspy._signals.signal2d.</code><code class="descname">hanning2d</code><span class="sig-paren">(</span><em>M</em>, <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.hanning2d" title="Permalink to this definition">¶</a></dt>
<dd><p>A 2D hanning window created by outer product.</p>
</dd></dl>

<dl class="function">
<dt id="hyperspy._signals.signal2d.shift_image">
<code class="descclassname">hyperspy._signals.signal2d.</code><code class="descname">shift_image</code><span class="sig-paren">(</span><em>im</em>, <em>shift=0</em>, <em>interpolation_order=1</em>, <em>fill_value=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.shift_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="hyperspy._signals.signal2d.sobel_filter">
<code class="descclassname">hyperspy._signals.signal2d.</code><code class="descname">sobel_filter</code><span class="sig-paren">(</span><em>im</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.sobel_filter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="hyperspy._signals.signal2d.triu_indices_minus_diag">
<code class="descclassname">hyperspy._signals.signal2d.</code><code class="descname">triu_indices_minus_diag</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.signal2d.triu_indices_minus_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices for the upper-triangle of an (n, n) array
excluding its diagonal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>int</em>) &#8211; The length of the square array</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-hyperspy._signals" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="hyperspy.datasets.html" class="btn btn-neutral float-right" title="hyperspy.datasets package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="hyperspy._components.html" class="btn btn-neutral" title="hyperspy._components package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2011-2016, The HyperSpy development team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/copybutton.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>