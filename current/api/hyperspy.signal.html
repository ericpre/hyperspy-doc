

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>hyperspy.signal module &mdash; HyperSpy 1.5.dev documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/hyperspy.ico"/>
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="hyperspy.signal_tools module" href="hyperspy.signal_tools.html" />
    <link rel="prev" title="hyperspy.samfire module" href="hyperspy.samfire.html" />
 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-25260850-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> HyperSpy
          

          
            
            <img src="../_static/hyperspy_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.5.dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../user_guide/index.html">HyperSpy User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Full HyperSpy API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="hyperspy.html">hyperspy package</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#subpackages">Subpackages</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="hyperspy.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="hyperspy.Release.html">hyperspy.Release module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy._lazy_signals.html">hyperspy._lazy_signals module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.api.html">hyperspy.api module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.api_nogui.html">hyperspy.api_nogui module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.axes.html">hyperspy.axes module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.component.html">hyperspy.component module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.components1d.html">hyperspy.components1d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.components2d.html">hyperspy.components2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.conftest.html">hyperspy.conftest module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.decorators.html">hyperspy.decorators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.defaults_parser.html">hyperspy.defaults_parser module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.events.html">hyperspy.events module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.exceptions.html">hyperspy.exceptions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.interactive.html">hyperspy.interactive module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.io.html">hyperspy.io module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.logger.html">hyperspy.logger module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.model.html">hyperspy.model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.roi.html">hyperspy.roi module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.samfire.html">hyperspy.samfire module</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">hyperspy.signal module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.signal_tools.html">hyperspy.signal_tools module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.signals.html">hyperspy.signals module</a></li>
<li class="toctree-l4"><a class="reference internal" href="hyperspy.ui_registry.html">hyperspy.ui_registry module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="hyperspy.html#module-hyperspy">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dev_guide.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citing.html">Citing HyperSpy</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">HyperSpy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">hyperspy</a> &raquo;</li>
        
          <li><a href="hyperspy.html">hyperspy package</a> &raquo;</li>
        
      <li>hyperspy.signal module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/hyperspy.signal.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-hyperspy.signal">
<span id="hyperspy-signal-module"></span><h1>hyperspy.signal module<a class="headerlink" href="#module-hyperspy.signal" title="Permalink to this headline">¶</a></h1>
<dl class="data">
<dt id="hyperspy.signal.ARITHMETIC_OPERATORS">
<code class="sig-prename descclassname">hyperspy.signal.</code><code class="sig-name descname">ARITHMETIC_OPERATORS</code><em class="property"> = ('__add__', '__sub__', '__mul__', '__floordiv__', '__mod__', '__divmod__', '__pow__', '__lshift__', '__rshift__', '__and__', '__xor__', '__or__', '__mod__', '__truediv__')</em><a class="headerlink" href="#hyperspy.signal.ARITHMETIC_OPERATORS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="hyperspy.signal.BaseSetMetadataItems">
<em class="property">class </em><code class="sig-prename descclassname">hyperspy.signal.</code><code class="sig-name descname">BaseSetMetadataItems</code><span class="sig-paren">(</span><em class="sig-param">signal</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSetMetadataItems" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">traits.has_traits.HasTraits</span></code></p>
<dl class="method">
<dt id="hyperspy.signal.BaseSetMetadataItems.store">
<code class="sig-name descname">store</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSetMetadataItems.store" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy.signal.BaseSignal">
<em class="property">class </em><code class="sig-prename descclassname">hyperspy.signal.</code><code class="sig-name descname">BaseSignal</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hyperspy.misc.slicing.html#hyperspy.misc.slicing.FancySlicing" title="hyperspy.misc.slicing.FancySlicing"><code class="xref py py-class docutils literal notranslate"><span class="pre">hyperspy.misc.slicing.FancySlicing</span></code></a>, <a class="reference internal" href="hyperspy.learn.mva.html#hyperspy.learn.mva.MVA" title="hyperspy.learn.mva.MVA"><code class="xref py py-class docutils literal notranslate"><span class="pre">hyperspy.learn.mva.MVA</span></code></a>, <a class="reference internal" href="#hyperspy.signal.MVATools" title="hyperspy.signal.MVATools"><code class="xref py py-class docutils literal notranslate"><span class="pre">hyperspy.signal.MVATools</span></code></a></p>
<dl class="method">
<dt id="hyperspy.signal.BaseSignal.T">
<em class="property">property </em><code class="sig-name descname">T</code><a class="headerlink" href="#hyperspy.signal.BaseSignal.T" title="Permalink to this definition">¶</a></dt>
<dd><p>The transpose of the signal, with signal and navigation spaces
swapped.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.add_gaussian_noise">
<code class="sig-name descname">add_gaussian_noise</code><span class="sig-paren">(</span><em class="sig-param">std</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.add_gaussian_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Gaussian noise to the data.</p>
<p>The operation is performed in-place i.e. the data of the signal
is modified.</p>
<p>This method requires a float data type, otherwise numpy raises a
<code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>std</strong> (<em>float</em>) – The standard deviation of the gaussian noise.</p></li>
<li><p><strong>Note</strong> – </p></li>
<li><p><strong>-----</strong> – </p></li>
<li><p><strong>method uses numpy.random.normal</strong><strong> (</strong><strong>dask.array.random.normal</strong> (<em>This</em>) – </p></li>
<li><p><strong>lazy signals</strong><strong>) </strong><strong>to generate the Gaussian noise. In order to seed it</strong> (<em>for</em>) – </p></li>
<li><p><strong>must use numpy.random.seed</strong><strong> (</strong><strong>dask.random.seed</strong><strong>)</strong><strong></strong> (<em>you</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.add_marker">
<code class="sig-name descname">add_marker</code><span class="sig-paren">(</span><em class="sig-param">marker</em>, <em class="sig-param">plot_on_signal=True</em>, <em class="sig-param">plot_marker=True</em>, <em class="sig-param">permanent=False</em>, <em class="sig-param">plot_signal=True</em>, <em class="sig-param">render_figure=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.add_marker" title="Permalink to this definition">¶</a></dt>
<dd><p>Add one or several markers to the signal or navigator plot.</p>
<p>Plot the signal, if not yet plotted</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>marker</strong> (<em>marker object</em><em> or </em><em>iterable of marker objects</em>) – The marker or iterable (list, tuple, …) of markers to add.
See <cite>plot.markers</cite>. If you want to add a large number of markers,
add them as an iterable, since this will be much faster.
For signals with navigation dimensions, the markers can be
made to change for different navigation indices. See the examples
for info.</p></li>
<li><p><strong>plot_on_signal</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True, add the marker to the signal
If False, add the marker to the navigator</p></li>
<li><p><strong>plot_marker</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True, plot the marker.</p></li>
<li><p><strong>permanent</strong> (<em>bool</em><em>, </em><em>default False</em>) – If False, the marker will only appear in the current
plot. If True, the marker will be added to the
metadata.Markers list, and be plotted with plot(plot_markers=True).
If the signal is saved as a HyperSpy HDF5 file, the markers will be
stored in the HDF5 signal and be restored when the file is loaded.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.misc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">markers</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                 <span class="n">y2</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">add_marker</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Adding to a 1D signal, where the point will change
when the navigation index is changed.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">marker</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">markers</span><span class="o">.</span><span class="n">point</span><span class="p">((</span><span class="mi">19</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_marker</span><span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">permanent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_marker</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Add permanent marker</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">marker</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">markers</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_marker</span><span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">permanent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_marker</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Add permanent marker to signal with 2 navigation dimensions.
The signal has navigation dimensions (3, 2), as the dimensions
gets flipped compared to the output from np.random.random.
To add a vertical line marker which changes for different navigation
indices, the list used to make the marker must be a nested list:
2 lists with 3 elements each (2 x 3).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">marker</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">markers</span><span class="o">.</span><span class="n">vertical_line</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_marker</span><span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">permanent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Add permanent marker which changes with navigation position, and
do not add it to a current plot</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">marker</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">markers</span><span class="o">.</span><span class="n">point</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_marker</span><span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">permanent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_marker</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">plot_markers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#doctest: +SKIP</span>
</pre></div>
</div>
<p>Removing a permanent marker</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">marker</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">markers</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">marker</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;point_marker&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_marker</span><span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">permanent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">s</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">Markers</span><span class="o">.</span><span class="n">point_marker</span>
</pre></div>
</div>
<p>Adding many markers as a list</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">random</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">marker_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">marker</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">markers</span><span class="o">.</span><span class="n">point</span><span class="p">(</span><span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="n">random</span><span class="p">()</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">marker_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_marker</span><span class="p">(</span><span class="n">marker_list</span><span class="p">,</span> <span class="n">permanent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.add_poissonian_noise">
<code class="sig-name descname">add_poissonian_noise</code><span class="sig-paren">(</span><em class="sig-param">keep_dtype=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.add_poissonian_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Poissonian noise to the data</p>
<p>This method works in-place. The resulting data type is int64. If this
is different from the original data type a warning is added to the
log.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>keep_dtype</strong> (<em>bool</em>) – If <cite>True</cite>, keep the original data type of the signal data. For
example, if the data type was initially “float64”, the result of
the operation (usually “int64”) will be converted to “float64”.
The default is <code class="docutils literal notranslate"><span class="pre">True</span></code> for convienece.</p></li>
<li><p><strong>Note</strong> – </p></li>
<li><p><strong>-----</strong> – </p></li>
<li><p><strong>method uses numpy.random.poisson</strong><strong> (</strong><strong>dask.array.random.poisson</strong> (<em>This</em>) – </p></li>
<li><p><strong>lazy signals</strong><strong>) </strong><strong>to generate the Gaussian noise. In order to seed it</strong> (<em>for</em>) – </p></li>
<li><p><strong>must use numpy.random.seed</strong><strong> (</strong><strong>dask.random.seed</strong><strong>)</strong><strong></strong> (<em>you</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.as_lazy">
<code class="sig-name descname">as_lazy</code><span class="sig-paren">(</span><em class="sig-param">copy_variance=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.as_lazy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.as_signal1D">
<code class="sig-name descname">as_signal1D</code><span class="sig-paren">(</span><em class="sig-param">spectral_axis</em>, <em class="sig-param">out=None</em>, <em class="sig-param">optimize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.as_signal1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Signal as a spectrum.</p>
<p>The chosen spectral axis is moved to the last index in the
array and the data is made contiguous for efficient iteration over
spectra. By default ensures the data is stored optimally, hence often
making a copy of the data. See <cite>transpose</cite> for a more general method
with more options.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spectral_axis</strong> (int, str or <cite>axis</cite>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>optimize</strong> (<em>bool</em>) – If True, the location of the data in memory is optimised for the
fastest iteration over the navigation axes. This operation can
cause a peak of memory usage and requires considerable processing
times for large datasets and/or low specification hardware.
See the <cite>transposing</cite> section of the HyperSpy user guide
for more information. When operating on lazy signals, if <cite>True</cite>
the chunks are optimised for the new axes configuration.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.as_signal2D" title="hyperspy.signal.BaseSignal.as_signal2D"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_signal2D()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.transpose" title="hyperspy.signal.BaseSignal.transpose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transpose()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">hs.transpose()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span>
<span class="go">&lt;Signal2D, title: , dimensions: (4, 3, 6, 5)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">to_spectrum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">&lt;Signal1D, title: , dimensions: (6, 5, 4, 3)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">to_spectrum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&lt;Signal1D, title: , dimensions: (6, 5, 3, 4)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.as_signal2D">
<code class="sig-name descname">as_signal2D</code><span class="sig-paren">(</span><em class="sig-param">image_axes</em>, <em class="sig-param">out=None</em>, <em class="sig-param">optimize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.as_signal2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert signal to image.</p>
<p>The chosen image axes are moved to the last indices in the
array and the data is made contiguous for efficient
iteration over images.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_axes</strong> (<em>tuple of {int | str | axis}</em>) – Select the image axes. Note that the order of the axes matters
and it is given in the “natural” i.e. X, Y, Z… order.</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>optimize</strong> (<em>bool</em>) – If True, the location of the data in memory is optimised for the
fastest iteration over the navigation axes. This operation can
cause a peak of memory usage and requires considerable processing
times for large datasets and/or low specification hardware.
See the <cite>transposing</cite> section of the HyperSpy user guide
for more information. When operating on lazy signals, if <cite>True</cite>
the chunks are optimised for the new axes configuration.</p></li>
</ul>
</dd>
</dl>
<p>:raises DataDimensionError : when data.ndim &lt; 2:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.as_signal1D" title="hyperspy.signal.BaseSignal.as_signal1D"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_signal1D()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.transpose" title="hyperspy.signal.BaseSignal.transpose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transpose()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">hs.transpose()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;Signal1D, title: , dimensions: (4, 3, 2, 5)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">as_signal2D</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">&lt;Signal2D, title: , dimensions: (5, 2, 4, 3)&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">to_signal2D</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">&lt;Signal2D, title: , dimensions: (4, 5, 3, 2)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.change_dtype">
<code class="sig-name descname">change_dtype</code><span class="sig-paren">(</span><em class="sig-param">dtype</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.change_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the data type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dtype</strong> (<em>str</em><em> or </em><em>dtype</em>) – Typecode or data-type to which the array is cast. In addition to all
standard numpy dtypes HyperSpy supports four extra dtypes for RGB
images: “rgb8”, “rgba8”, “rgb16” and “rgba16”. Changing from and to
any rgbx dtype is more constrained than most other dtype
conversions. To change to a rgbx dtype the signal dimension must be
1, its size 3(4) for rgb(rgba) dtypes, the dtype uint8(uint16) for
rgbx8(rgbx16) and the navigation dimension at least 2. After
conversion the signal dimension becomes 2. The dtype of images of
dtype rgbx8(rgbx16) can only be changed to uint8(uint16) and the
signal dimension becomes 1.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span>
<span class="go">array([1, 2, 3, 4, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">change_dtype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span>
<span class="go">array([ 1.,  2.,  3.,  4.,  5.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.crop">
<code class="sig-name descname">crop</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">start=None</em>, <em class="sig-param">end=None</em>, <em class="sig-param">convert_units=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crops the data in a given axis. The range is given in pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (<em>{int | string}</em>) – Specify the data axis in which to perform the cropping
operation. The axis can be specified using the index of the
axis in <cite>axes_manager</cite> or the axis name.</p></li>
<li><p><strong>end</strong> (<em>start</em><em>,</em>) – The beginning and end of the cropping interval. If int
the value is taken as the axis index. If float the index
is calculated using the axis calibration. If start/end is
None crop from/to the low/high end of the axis.</p></li>
<li><p><strong>convert_units</strong> (<em>bool</em>) – Default is False
If True, convert the units using the <cite>convert_to_units</cite> method of
the <cite>axes_manager</cite>. If False, does nothing.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.data">
<em class="property">property </em><code class="sig-name descname">data</code><a class="headerlink" href="#hyperspy.signal.BaseSignal.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.deepcopy">
<code class="sig-name descname">deepcopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.derivative">
<code class="sig-name descname">derivative</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">order=1</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerical derivative along the given axis.</p>
<p>Currently only the first order finite difference method is implemented.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str or <cite>axis</cite>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – The order of the derivative. (Note that this is the order of the
derivative i.e. <cite>order=2</cite> does not use second order finite
differences method.)</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>der</strong> – Note that the size of the data on the given <cite>axis</cite> decreases by the
given <cite>order</cite> i.e. if <cite>axis</cite> is “x” and <cite>order</cite> is 2 the
x dimension is N, der’s x dimension is N - 2.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.diff" title="hyperspy.signal.BaseSignal.diff"><code class="xref py py-meth docutils literal notranslate"><span class="pre">diff()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.diff">
<code class="sig-name descname">diff</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">order=1</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the n-th order discrete difference along
given axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str or <cite>axis</cite>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – the order of the derivative</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.max" title="hyperspy.signal.BaseSignal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.min" title="hyperspy.signal.BaseSignal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.sum" title="hyperspy.signal.BaseSignal.sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.mean" title="hyperspy.signal.BaseSignal.mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mean()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.std" title="hyperspy.signal.BaseSignal.std"><code class="xref py py-meth docutils literal notranslate"><span class="pre">std()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.var" title="hyperspy.signal.BaseSignal.var"><code class="xref py py-meth docutils literal notranslate"><span class="pre">var()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.indexmax" title="hyperspy.signal.BaseSignal.indexmax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">indexmax()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.valuemax" title="hyperspy.signal.BaseSignal.valuemax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">valuemax()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">amax()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1023)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.estimate_poissonian_noise_variance">
<code class="sig-name descname">estimate_poissonian_noise_variance</code><span class="sig-paren">(</span><em class="sig-param">expected_value=None</em>, <em class="sig-param">gain_factor=None</em>, <em class="sig-param">gain_offset=None</em>, <em class="sig-param">correlation_factor=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.estimate_poissonian_noise_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the poissonian noise variance of the signal.</p>
<p>The variance is stored in the
<code class="docutils literal notranslate"><span class="pre">metadata.Signal.Noise_properties.variance</span></code> attribute.</p>
<p>A poissonian noise  variance is equal to the expected value. With the
default arguments, this method simply sets the variance attribute to
the given <cite>expected_value</cite>. However, more generally (although then
noise is not strictly poissonian), the variance may be proportional to
the expected value. Moreover, when the noise is a mixture of white
(gaussian) and poissonian noise, the variance is described by the
following linear model:</p>
<blockquote>
<div><div class="math">
<p><img src="../_images/math/b64bd31fca2efe14aec8958276ccb62823b7164a.png" alt="\mathrm{Var}[X] = (a * \mathrm{E}[X] + b) * c"/></p>
</div></div></blockquote>
<p>Where <cite>a</cite> is the <cite>gain_factor</cite>, <cite>b</cite> is the <cite>gain_offset</cite> (the gaussian
noise variance) and <cite>c</cite> the <cite>correlation_factor</cite>. The correlation
factor accounts for correlation of adjacent signal elements that can
be modeled as a convolution with a gaussian point spread function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expected_value</strong> (<em>None</em><em> or </em><em>Signal instance.</em>) – If None, the signal data is taken as the expected value. Note that
this may be inaccurate where <cite>data</cite> is small.</p></li>
<li><p><strong>gain_offset</strong><strong>, </strong><strong>correlation_factor</strong> (<em>gain_factor</em><em>,</em>) – All three must be positive. If None, take the values from
<code class="docutils literal notranslate"><span class="pre">metadata.Signal.Noise_properties.Variance_linear_model</span></code> if
defined. Otherwise suppose poissonian noise i.e. <code class="docutils literal notranslate"><span class="pre">gain_factor=1</span></code>,
<code class="docutils literal notranslate"><span class="pre">gain_offset=0</span></code>, <code class="docutils literal notranslate"><span class="pre">correlation_factor=1</span></code>. If not None, the
values are stored in
<code class="docutils literal notranslate"><span class="pre">metadata.Signal.Noise_properties.Variance_linear_model</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.fft">
<code class="sig-name descname">fft</code><span class="sig-paren">(</span><em class="sig-param">shift=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the discrete Fourier Transform.</p>
<p>This function computes the discrete Fourier Transform over the signal
axes by means of the Fast Fourier Transform (FFT) as implemented in
numpy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shift</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the origin of FFT will be shifted to the centre (Default: False).</p></li>
<li><p><strong>**kwargs</strong> – other keyword arguments are described in np.fft.fftn().</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="hyperspy._signals.complex_signal.html#hyperspy._signals.complex_signal.ComplexSignal" title="hyperspy._signals.complex_signal.ComplexSignal">ComplexSignal</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span>
<span class="go">&lt;ComplexSignal2D, title: FFT of , dimensions: (|512, 512)&gt;</span>
<span class="go"># Use following to plot power spectrum of `im`:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>For further information see the documentation of numpy.fft.fftn</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.fold">
<code class="sig-name descname">fold</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.fold" title="Permalink to this definition">¶</a></dt>
<dd><p>If the signal was previously unfolded, folds it back</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.get_current_signal">
<code class="sig-name descname">get_current_signal</code><span class="sig-paren">(</span><em class="sig-param">auto_title=True</em>, <em class="sig-param">auto_filename=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.get_current_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data at the current coordinates as a Signal subclass.</p>
<p>The signal subclass is the same as that of the current object. All the
axes navigation attribute are set to False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>auto_title</strong> (<em>bool</em>) – If True an space followed by the current indices in parenthesis
are appended to the title.</p></li>
<li><p><strong>auto_filename</strong> (<em>bool</em>) – If True and <cite>tmp_parameters.filename</cite> is defined
(what is always the case when the Signal has been read from a
file), the filename is modified by appending an underscore and a
parenthesis containing the current indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cs</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal subclass instance.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span>
<span class="go">&lt;Signal2D, title: , dimensions: (3, 2, 32, 32)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">axes_manager</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">get_current_signal</span><span class="p">()</span>
<span class="go">&lt;Signal2D, title:  (2, 1), dimensions: (32, 32)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.get_dimensions_from_data">
<code class="sig-name descname">get_dimensions_from_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.get_dimensions_from_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dimension parameters from the data_cube. Useful when
the data_cube was externally modified, or when the SI was not
loaded from a file</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.get_histogram">
<code class="sig-name descname">get_histogram</code><span class="sig-paren">(</span><em class="sig-param">bins='freedman'</em>, <em class="sig-param">range_bins=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.get_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a histogram of the signal data.</p>
<p>More sophisticated algorithms for determining bins can be used.
Aside from the <cite>bins</cite> argument allowing a string specified how bins
are computed, the parameters are the same as numpy.histogram().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bins</strong> (<em>int</em><em> or </em><em>list</em><em> or </em><em>str</em><em>, </em><em>optional</em>) – If bins is a string, then it must be one of:
‘knuth’ : use Knuth’s rule to determine bins
‘scotts’ : use Scott’s rule to determine bins
‘freedman’ : use the Freedman-diaconis rule to determine bins
‘blocks’ : use bayesian blocks for dynamic bin widths</p></li>
<li><p><strong>range_bins</strong> (<em>tuple</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – the minimum and maximum range for the histogram. If not specified,
it will be (x.min(), x.max())</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
<li><p><strong>**kwargs</strong> – other keyword arguments (weight and density) are described in
np.histogram().</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>hist_spec</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>An 1D spectrum instance containing the histogram.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.print_summary_statistics" title="hyperspy.signal.BaseSignal.print_summary_statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_summary_statistics()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">astroML.density_estimation.histogram()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">numpy.histogram()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The lazy version of the algorithm does not support ‘knuth’ and ‘blocks’
bins arguments.
The number of bins estimators are taken from AstroML. Read
their documentation for more info.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)))</span>
<span class="go">Plot the data histogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_histogram</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Plot the histogram of the signal at the current coordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_current_signal</span><span class="p">()</span><span class="o">.</span><span class="n">get_histogram</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.ifft">
<code class="sig-name descname">ifft</code><span class="sig-paren">(</span><em class="sig-param">shift=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.ifft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse discrete Fourier Transform.</p>
<p>This function computes real part of the inverse of the discrete
Fourier Transform over the signal axes by means of the
Fast Fourier Transform (FFT) as implemented in
numpy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shift</strong> (<em>bool</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – If None the shift option will be set to the original status of the
FFT using value in metadata. If no FFT entry is present in
metadata, the parameter will be set to False. If True, the origin
of FFT will be shifted to the centre, otherwise the origin would
be kept at (0, 0)(Default: None).</p></li>
<li><p><strong>**kwargs</strong> – other keyword arguments are described in np.fft.ifftn().</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">ascent</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imfft</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imfft</span><span class="o">.</span><span class="n">ifft</span><span class="p">()</span>
<span class="go">&lt;Signal2D, title: real(iFFT of FFT of ), dimensions: (|512, 512)&gt;</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>For further information see the documentation of numpy.fft.ifftn</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.indexmax">
<code class="sig-name descname">indexmax</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.indexmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the index of the maximum along an axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str or <cite>axis</cite>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong> – The data dtype is always int.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>max, min, sum, mean, std, var, valuemax, amax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">indexmax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.indexmin">
<code class="sig-name descname">indexmin</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.indexmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the index of the minimum along an axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str or <cite>axis</cite>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong> – The data dtype is always int.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>max, min, sum, mean, std, var, valuemax, amax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">indexmin</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.integrate1D">
<code class="sig-name descname">integrate1D</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.integrate1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate the signal over the given axis.</p>
<p>The integration is performed using Simpson’s rule if
<cite>metadata.Signal.binned</cite> is False and summation over the given axis if
True.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str or <cite>axis</cite>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.integrate_simpson" title="hyperspy.signal.BaseSignal.integrate_simpson"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate_simpson()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.diff" title="hyperspy.signal.BaseSignal.diff"><code class="xref py py-meth docutils literal notranslate"><span class="pre">diff()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.derivative" title="hyperspy.signal.BaseSignal.derivative"><code class="xref py py-meth docutils literal notranslate"><span class="pre">derivative()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">integrate1D</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.integrate_simpson">
<code class="sig-name descname">integrate_simpson</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.integrate_simpson" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the result of calculating the integral
of the signal along an axis using Simpson’s rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str or <cite>axis</cite>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.max" title="hyperspy.signal.BaseSignal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.min" title="hyperspy.signal.BaseSignal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.sum" title="hyperspy.signal.BaseSignal.sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.mean" title="hyperspy.signal.BaseSignal.mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mean()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.std" title="hyperspy.signal.BaseSignal.std"><code class="xref py py-meth docutils literal notranslate"><span class="pre">std()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.var" title="hyperspy.signal.BaseSignal.var"><code class="xref py py-meth docutils literal notranslate"><span class="pre">var()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.indexmax" title="hyperspy.signal.BaseSignal.indexmax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">indexmax()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.valuemax" title="hyperspy.signal.BaseSignal.valuemax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">valuemax()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">amax()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">integrate_simpson</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.is_rgb">
<em class="property">property </em><code class="sig-name descname">is_rgb</code><a class="headerlink" href="#hyperspy.signal.BaseSignal.is_rgb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.is_rgba">
<em class="property">property </em><code class="sig-name descname">is_rgba</code><a class="headerlink" href="#hyperspy.signal.BaseSignal.is_rgba" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.is_rgbx">
<em class="property">property </em><code class="sig-name descname">is_rgbx</code><a class="headerlink" href="#hyperspy.signal.BaseSignal.is_rgbx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.map">
<code class="sig-name descname">map</code><span class="sig-paren">(</span><em class="sig-param">function</em>, <em class="sig-param">show_progressbar=None</em>, <em class="sig-param">parallel=None</em>, <em class="sig-param">inplace=True</em>, <em class="sig-param">ragged=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to the signal data at all the coordinates.</p>
<p>The function must operate on numpy arrays. It is applied to the data at
each navigation coordinate pixel-py-pixel. Any extra keyword argument
is passed to the function. The keywords can take different values at
different coordinates. If the function takes an <cite>axis</cite> or <cite>axes</cite>
argument, the function is assumed to be vectorial and the signal axes
are assigned to <cite>axis</cite> or <cite>axes</cite>.  Otherwise, the signal is iterated
over the navigation axes and a progress bar is displayed to monitor the
progress.</p>
<p>In general, only navigation axes (order, calibration and number) is
guaranteed to be preserved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>function</em>) – A function that can be applied to the signal.</p></li>
<li><p><strong>show_progressbar</strong> (<em>None</em><em> or </em><em>bool</em>) – If True, display a progress bar. If None the default from the
preferences settings is used.</p></li>
<li><p><strong>parallel</strong> (<em>None</em><em> or </em><em>bool</em>) – If True, perform computation in parallel using multiple cores. If
None the default from the preferences settings is used.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em>) – if True (default), the data is replaced by the result. Otherwise a
new signal with the results is returned.</p></li>
<li><p><strong>ragged</strong> (<em>{None</em><em>, </em><em>bool}</em>) – Indicates if results for each navigation pixel are of identical
shape (and/or numpy arrays to begin with). If None, appropriate
choice is made while processing. None is not allowed for Lazy
signals!</p></li>
<li><p><strong>arguments</strong> (<em>keyword</em>) – All extra keyword arguments are passed to the</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the function results do not have identical shapes, the result is an
array of navigation shape, where each element corresponds to the result
of the function (of arbitrary object type), called “ragged array”. As
such, most functions are not able to operate on the result and the data
should be used directly.</p>
<p>This method is similar to Python’s <a class="reference internal" href="#hyperspy.signal.BaseSignal.map" title="hyperspy.signal.BaseSignal.map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> that can also be utilize
with a <code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code> instance for similar purposes. However, this
method has the advantage of being faster because it iterates the numpy
array instead of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Signal</span></code>.</p>
<p class="rubric">Examples</p>
<p>Apply a Gaussian filter to all the images in the dataset. The sigma
parameter is constant.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.ndimage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply a Gaussian filter to all the images in the dataset. The signal
parameter is variable.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigmas</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigmas</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the maximum of the signal along at least one
axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None) – Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.min" title="hyperspy.signal.BaseSignal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.sum" title="hyperspy.signal.BaseSignal.sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.mean" title="hyperspy.signal.BaseSignal.mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mean()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.std" title="hyperspy.signal.BaseSignal.std"><code class="xref py py-meth docutils literal notranslate"><span class="pre">std()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.var" title="hyperspy.signal.BaseSignal.var"><code class="xref py py-meth docutils literal notranslate"><span class="pre">var()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.indexmax" title="hyperspy.signal.BaseSignal.indexmax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">indexmax()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.valuemax" title="hyperspy.signal.BaseSignal.valuemax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">valuemax()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">amax()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the average of the signal along at least one
axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None) – Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.max" title="hyperspy.signal.BaseSignal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.min" title="hyperspy.signal.BaseSignal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.sum" title="hyperspy.signal.BaseSignal.sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.std" title="hyperspy.signal.BaseSignal.std"><code class="xref py py-meth docutils literal notranslate"><span class="pre">std()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.var" title="hyperspy.signal.BaseSignal.var"><code class="xref py py-meth docutils literal notranslate"><span class="pre">var()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.indexmax" title="hyperspy.signal.BaseSignal.indexmax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">indexmax()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.valuemax" title="hyperspy.signal.BaseSignal.valuemax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">valuemax()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">amax()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the minimum of the signal along at least one
axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None) – Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.max" title="hyperspy.signal.BaseSignal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.sum" title="hyperspy.signal.BaseSignal.sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.mean" title="hyperspy.signal.BaseSignal.mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mean()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.std" title="hyperspy.signal.BaseSignal.std"><code class="xref py py-meth docutils literal notranslate"><span class="pre">std()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.var" title="hyperspy.signal.BaseSignal.var"><code class="xref py py-meth docutils literal notranslate"><span class="pre">var()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.indexmax" title="hyperspy.signal.BaseSignal.indexmax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">indexmax()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.valuemax" title="hyperspy.signal.BaseSignal.valuemax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">valuemax()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">amax()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.nanmax">
<code class="sig-name descname">nanmax</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.nanmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to max except ignores missing (NaN) values.
The full documentation follows:</p>
<dl>
<dt>——————– max ——————–</dt><dd><p>Returns a signal with the maximum of the signal along at least one
axis.</p>
<dl>
<dt>axis<span class="classifier">int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None</span></dt><dd><p>Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p>
</dd>
<dt>out<span class="classifier"><cite>Signal</cite> or None</span></dt><dd><p>If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p>
</dd>
<dt>rechunk: bool</dt><dd><p>Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p>
</dd>
</dl>
<p>s : Signal</p>
<p>min, sum, mean, std, var, indexmax, valuemax, amax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.nanmean">
<code class="sig-name descname">nanmean</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.nanmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to mean except ignores missing (NaN) values.
The full documentation follows:</p>
<dl>
<dt>——————– mean ——————–</dt><dd><p>Returns a signal with the average of the signal along at least one
axis.</p>
<dl>
<dt>axis<span class="classifier">int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None</span></dt><dd><p>Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p>
</dd>
<dt>out<span class="classifier"><cite>Signal</cite> or None</span></dt><dd><p>If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p>
</dd>
<dt>rechunk: bool</dt><dd><p>Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p>
</dd>
</dl>
<p>s : Signal</p>
<p>max, min, sum, std, var, indexmax, valuemax, amax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.nanmin">
<code class="sig-name descname">nanmin</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.nanmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to min except ignores missing (NaN) values.
The full documentation follows:</p>
<dl>
<dt>——————– min ——————–</dt><dd><p>Returns a signal with the minimum of the signal along at least one
axis.</p>
<dl>
<dt>axis<span class="classifier">int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None</span></dt><dd><p>Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p>
</dd>
<dt>out<span class="classifier"><cite>Signal</cite> or None</span></dt><dd><p>If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p>
</dd>
<dt>rechunk: bool</dt><dd><p>Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p>
</dd>
</dl>
<p>s : Signal</p>
<p>max, sum, mean, std, var, indexmax, valuemax, amax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.nanstd">
<code class="sig-name descname">nanstd</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.nanstd" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to std except ignores missing (NaN) values.
The full documentation follows:</p>
<dl>
<dt>——————– std ——————–</dt><dd><p>Returns a signal with the standard deviation of the signal along
at least one axis.</p>
<dl>
<dt>axis<span class="classifier">int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None</span></dt><dd><p>Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p>
</dd>
<dt>out<span class="classifier"><cite>Signal</cite> or None</span></dt><dd><p>If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p>
</dd>
<dt>rechunk: bool</dt><dd><p>Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p>
</dd>
</dl>
<p>s : Signal</p>
<p>max, min, sum, mean, var, indexmax, valuemax, amax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.nansum">
<code class="sig-name descname">nansum</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.nansum" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to sum except ignores missing (NaN) values.
The full documentation follows:</p>
<dl>
<dt>——————– sum ——————–</dt><dd><p>Sum the data over the given axes.</p>
<dl>
<dt>axis<span class="classifier">int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None</span></dt><dd><p>Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p>
</dd>
<dt>out<span class="classifier"><cite>Signal</cite> or None</span></dt><dd><p>If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p>
</dd>
<dt>rechunk: bool</dt><dd><p>Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p>
</dd>
</dl>
<p>s : Signal</p>
<p>max, min, mean, std, var, indexmax, valuemax, amax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.nanvar">
<code class="sig-name descname">nanvar</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.nanvar" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to var except ignores missing (NaN) values.
The full documentation follows:</p>
<dl>
<dt>——————– var ——————–</dt><dd><p>Returns a signal with the variances of the signal along at least one
axis.</p>
<dl>
<dt>axis<span class="classifier">int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None</span></dt><dd><p>Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p>
</dd>
<dt>out<span class="classifier"><cite>Signal</cite> or None</span></dt><dd><p>If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p>
</dd>
<dt>rechunk: bool</dt><dd><p>Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p>
</dd>
</dl>
<p>s : Signal</p>
<p>max, min, sum, mean, std, indexmax, valuemax, amax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">navigator='auto'</em>, <em class="sig-param">axes_manager=None</em>, <em class="sig-param">plot_markers=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the signal at the current coordinates.</p>
<p>For multidimensional datasets an optional figure,
the “navigator”, with a cursor to navigate that data is
raised. In any case it is possible to navigate the data using
the sliders. Currently only signals with signal_dimension equal to
0, 1 and 2 can be plotted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>navigator</strong> (<em>{&quot;auto&quot;</em><em>, </em><em>None</em><em>, </em><em>&quot;slider&quot;</em><em>, </em><em>&quot;spectrum&quot;</em><em>, </em><em>Signal}</em>) – If “auto”, if navigation_dimension &gt; 0, a navigator is
provided to explore the data.
If navigation_dimension is 1 and the signal is an image
the navigator is a spectrum obtained by integrating
over the signal axes (the image).
If navigation_dimension is 1 and the signal is a spectrum
the navigator is an image obtained by stacking horizontally
all the spectra in the dataset.
If navigation_dimension is &gt; 1, the navigator is an image
obtained by integrating the data over the signal axes.
Additionaly, if navigation_dimension &gt; 2 a window
with one slider per axis is raised to navigate the data.
For example,
if the dataset consists of 3 navigation axes X, Y, Z and one
signal axis, E, the default navigator will be an image
obtained by integrating the data over E at the current Z
index and a window with sliders for the X, Y and Z axes
will be raised. Notice that changing the Z-axis index
changes the navigator in this case.
If “slider” and the navigation dimension &gt; 0 a window
with one slider per axis is raised to navigate the data.
If “spectrum” and navigation_dimension &gt; 0 the navigator
is always a spectrum obtained by integrating the data
over all other axes.
If None, no navigator will be provided.
Alternatively a Signal instance can be provided. The signal
dimension must be 1 (for a spectrum navigator) or 2 (for a
image navigator) and navigation_shape must be 0 (for a static
navigator) or navigation_shape + signal_shape must be equal
to the navigator_shape of the current object (for a dynamic
navigator).
If the signal dtype is RGB or RGBA this parameters has no
effect and is always “slider”.</p></li>
<li><p><strong>axes_manager</strong> (<em>{None</em><em>, </em><em>axes_manager}</em>) – If None <cite>axes_manager</cite> is used.</p></li>
<li><p><strong>plot_markers</strong> (<em>bool</em><em>, </em><em>default True</em>) – Plot markers added using s.add_marker(marker, permanent=True).
Note, a large number of markers might lead to very slow plotting.</p></li>
<li><p><strong>norm</strong> ({‘auto’, ‘linear’, ‘log’, mpl <cite>Normalize</cite> instance or subclass},) – default is ‘auto’.
Plot the intensity scale on a linear or logarithmic scale. If
‘auto’, plot the intensity on a linear scale except when
<cite>power_spectrum</cite> is True, which can be used only for compatible
signal. For Signal2D, a matplotlib <cite>Normalize</cite> subclass or
instance can be provided.</p></li>
<li><p><strong>optional</strong> (<em>**kwargs</em><em>,</em>) – Only for 2D signals: additional key word arguments for
<cite>matplotlib.pyplot.imshow</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.print_summary_statistics">
<code class="sig-name descname">print_summary_statistics</code><span class="sig-paren">(</span><em class="sig-param">formatter='%.3g'</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.print_summary_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the five-number summary statistics of the data, the mean and
the standard deviation.</p>
<p>Prints the mean, standard deviation (std), maximum (max), minimum
(min), first quartile (Q1), median and third quartile. nans are
removed from the calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formatter</strong> (<em>bool</em>) – Number formatter.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.get_histogram" title="hyperspy.signal.BaseSignal.get_histogram"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_histogram()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.rebin">
<code class="sig-name descname">rebin</code><span class="sig-paren">(</span><em class="sig-param">new_shape=None</em>, <em class="sig-param">scale=None</em>, <em class="sig-param">crop=True</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.rebin" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebin array.</p>
<p>Rebin the signal into a smaller or larger shape, based on linear
interpolation. Specify <strong>either</strong> new_shape or scale.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_shape</strong> (<em>a list of floats</em><em> or </em><em>integer</em><em>, </em><em>default None</em>) – For each dimension specify the new_shape. This will
then be converted into a scale.</p></li>
<li><p><strong>scale</strong> (<em>a list of floats</em><em> or </em><em>integer</em><em>, </em><em>default None</em>) – For each dimension specify the new:old pixel ratio, e.g. a ratio of 1
is no binning and a ratio of 2 means that each pixel in the new
spectrum is twice the size of the pixels in the old spectrum.
The length of the list should match the dimension of the numpy array.
<strong>*Note : Only one of scale or new_shape should be specified otherwise
the function will not run*</strong></p></li>
<li><p><strong>crop</strong> (<em>bool</em><em>, </em><em>default True</em>) – <p>When binning by a non-integer number of pixels it is likely that
the final row in each dimension contains less than the full quota to
fill one pixel.</p>
<p>e.g. 5*5 array binned by 2.1 will produce two rows containing 2.1
pixels and one row containing only 0.8 pixels worth. Selection of
crop=’True’ or crop=’False’ determines whether or not this
‘black’ line is cropped from the final binned array or not.</p>
<p><em>Please note that if crop=False is used, the final row in each
dimension may appear black, if a fractional number of pixels are left
over. It can be removed but has been left to preserve total counts
before and after binning.</em></p>
</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal subclass</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">EDSTEMSpectrum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectrum</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
<span class="go">&lt;EDXTEMSpectrum, title: dimensions: (4, 4|10)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;Sum = &#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">data</span><span class="p">))))</span>
<span class="go">Sum = 164.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="go">&lt;EDSTEMSpectrum, title: dimensions (2, 2|2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sum = &#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">test</span><span class="o">.</span><span class="n">data</span><span class="p">))))</span>
<span class="go">Sum =  164.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.rollaxis">
<code class="sig-name descname">rollaxis</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">to_axis</em>, <em class="sig-param">optimize=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.rollaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll the specified axis backwards, until it lies in a given position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str or <cite>axis</cite>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name. The axis to roll backwards.
The positions of the other axes do not change relative to one another.</p></li>
<li><p><strong>to_axis</strong> (int, str or <cite>axis</cite>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name. The axis is rolled until it
lies before this other axis.</p></li>
<li><p><strong>optimize</strong> (<em>bool</em>) – If True, the location of the data in memory is optimised for the
fastest iteration over the navigation axes. This operation can
cause a peak of memory usage and requires considerable processing
times for large datasets and/or low specification hardware.
See the <cite>transposing</cite> section of the HyperSpy user guide
for more information. When operating on lazy signals, if <cite>True</cite>
the chunks are optimised for the new axes configuration.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong> – Output signal.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal or subclass</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">roll()</span></code></dt><dd><p>swap_axes</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;Signal1D, title: , dimensions: (3, 4, 5, 6)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">&lt;Signal1D, title: , dimensions: (3, 4, 5, 6)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&lt;Signal1D, title: , dimensions: (5, 3, 4, 6)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">filename=None</em>, <em class="sig-param">overwrite=None</em>, <em class="sig-param">extension=None</em>, <em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the signal in the specified format.</p>
<dl class="simple">
<dt>The function gets the format from the extension.:</dt><dd><ul class="simple">
<li><p>hspy for HyperSpy’s HDF5 specification</p></li>
<li><p>rpl for Ripple (useful to export to Digital Micrograph)</p></li>
<li><p>msa for EMSA/MSA single spectrum saving.</p></li>
<li><p>unf for SEMPER unf binary format.</p></li>
<li><p>blo for Blockfile diffraction stack saving.</p></li>
<li><p>Many image formats such as png, tiff, jpeg…</p></li>
</ul>
</dd>
</dl>
<p>If no extension is provided the default file format as defined
in the <cite>preferences</cite> is used.
Please note that not all the formats supports saving datasets of
arbitrary dimensions, e.g. msa only supports 1D data, and blockfiles
only support image stacks with a navigation dimension &lt; 2.</p>
<p>Each format accepts a different set of parameters. For details
see the specific format documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em><em> or </em><em>None</em>) – If None (default) and tmp_parameters.filename and
<cite>tmp_paramters.folder</cite> are defined, the
filename and path will be taken from there. A valid
extension can be provided e.g. “my_file.rpl”, see <cite>extension</cite>.</p></li>
<li><p><strong>overwrite</strong> (<em>None</em><em>, </em><em>bool</em>) – If None, if the file exists it will query the user. If
True(False) it (does not) overwrites the file if it exists.</p></li>
<li><p><strong>extension</strong> (<em>{None</em><em>, </em><em>'hspy'</em><em>, </em><em>'hdf5'</em><em>, </em><em>'rpl'</em><em>, </em><em>'msa'</em><em>, </em><em>'unf'</em><em>, </em><em>'blo'</em><em>,</em>) – ‘emd’, common image extensions e.g. ‘tiff’, ‘png’}
The extension of the file that defines the file format.
‘hspy’ and ‘hdf5’ are equivalent. Use ‘hdf5’ if compatibility with
HyperSpy versions older than 1.2 is required.
If None, the extension is determined from the following list in
this order:
i) the filename
ii)  <cite>Signal.tmp_parameters.extension</cite>
iii) <cite>hspy</cite> (the default extension)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.set_signal_origin">
<code class="sig-name descname">set_signal_origin</code><span class="sig-paren">(</span><em class="sig-param">origin</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.set_signal_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the <cite>signal_origin</cite> metadata value.</p>
<p>The signal_origin attribute specifies if the data was obtained
through experiment or simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>origin</strong> (<em>string</em>) – Typically ‘experiment’ or ‘simulation’.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.set_signal_type">
<code class="sig-name descname">set_signal_type</code><span class="sig-paren">(</span><em class="sig-param">signal_type</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.set_signal_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the signal type and change the current class
accordingly if pertinent.</p>
<p>The signal_type attribute specifies the kind of data that the signal
contains e.g. “EELS” for electron energy-loss spectroscopy,
“PES” for photoemission spectroscopy. There are some methods that are
only available for certain kind of signals, so setting this
parameter can enable/disable features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>signal_type</strong> (<em>{&quot;EELS&quot;</em><em>, </em><em>&quot;EDS_TEM&quot;</em><em>, </em><em>&quot;EDS_SEM&quot;</em><em>, </em><em>&quot;DielectricFunction&quot;}</em>) – Currently there are special features for “EELS” (electron
energy-loss spectroscopy), “EDS_TEM” (energy dispersive X-rays of
thin samples, normally obtained in a transmission electron
microscope), “EDS_SEM” (energy dispersive X-rays of thick samples,
normally obtained in a scanning electron microscope) and
“DielectricFuction”. Setting the signal_type to the correct acronym
is highly advisable when analyzing any signal for which HyperSpy
provides extra features. Even if HyperSpy does not provide extra
features for the signal that you are analyzing, it is good practice
to set signal_type to a value that best describes the data signal
type.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">axis='auto'</em>, <em class="sig-param">number_of_parts='auto'</em>, <em class="sig-param">step_sizes='auto'</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits the data into several signals.</p>
<p>The split can be defined by giving the number_of_parts, a homogeneous
step size or a list of customized step sizes. By default (‘auto’),
the function is the reverse of utils.stack().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (<em>{'auto' | int | string}</em>) – <p>Specify the data axis in which to perform the splitting
operation.  The axis can be specified using the index of the
axis in <cite>axes_manager</cite> or the axis name.
- If ‘auto’ and if the object has been created with utils.stack,
split will return the former list of signals
(options stored in ‘metadata._HyperSpy.Stacking_history’</p>
<blockquote>
<div><p>else the last navigation axis will be used.</p>
</div></blockquote>
</p></li>
<li><p><strong>number_of_parts</strong> (<em>{'auto' | int}</em>) – Number of parts in which the SI will be split. The
splitting is homogeneous. When the axis size is not divisible
by the number_of_parts the reminder data is lost without
warning. If number_of_parts and step_sizes is ‘auto’,
number_of_parts equals the length of the axis,
step_sizes equals one  and the axis is suppressed from each
sub_spectra.</p></li>
<li><p><strong>step_sizes</strong> (<em>{'auto' | list of ints | int}</em>) – Size of the split parts. If ‘auto’, the step_sizes equals one.
If int, the splitting is homogeneous.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">Signal1D</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">    &lt;Signal1D, title: , dimensions: (3, 4|2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">    [&lt;Signal1D, title: , dimensions: (3 |2)&gt;,</span>
<span class="go">    &lt;Signal1D, title: , dimensions: (3 |2)&gt;,</span>
<span class="go">    &lt;Signal1D, title: , dimensions: (3 |2)&gt;,</span>
<span class="go">    &lt;Signal1D, title: , dimensions: (3 |2)&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">step_sizes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">    [&lt;Signal1D, title: , dimensions: (3, 2|2)&gt;,</span>
<span class="go">    &lt;Signal1D, title: , dimensions: (3, 2|2)&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">step_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">    [&lt;Signal1D, title: , dimensions: (3, 1|2)&gt;,</span>
<span class="go">    &lt;Signal1D, title: , dimensions: (3, 2|2)&gt;]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of the split signals</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.squeeze">
<code class="sig-name descname">squeeze</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove single-dimensional entries from the shape of an array
and the axes.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the standard deviation of the signal along
at least one axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None) – Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.max" title="hyperspy.signal.BaseSignal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.min" title="hyperspy.signal.BaseSignal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.sum" title="hyperspy.signal.BaseSignal.sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.mean" title="hyperspy.signal.BaseSignal.mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mean()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.var" title="hyperspy.signal.BaseSignal.var"><code class="xref py py-meth docutils literal notranslate"><span class="pre">var()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.indexmax" title="hyperspy.signal.BaseSignal.indexmax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">indexmax()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.valuemax" title="hyperspy.signal.BaseSignal.valuemax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">valuemax()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">amax()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum the data over the given axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None) – Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.max" title="hyperspy.signal.BaseSignal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.min" title="hyperspy.signal.BaseSignal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.mean" title="hyperspy.signal.BaseSignal.mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mean()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.std" title="hyperspy.signal.BaseSignal.std"><code class="xref py py-meth docutils literal notranslate"><span class="pre">std()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.var" title="hyperspy.signal.BaseSignal.var"><code class="xref py py-meth docutils literal notranslate"><span class="pre">var()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.indexmax" title="hyperspy.signal.BaseSignal.indexmax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">indexmax()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.valuemax" title="hyperspy.signal.BaseSignal.valuemax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">valuemax()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">amax()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.swap_axes">
<code class="sig-name descname">swap_axes</code><span class="sig-paren">(</span><em class="sig-param">axis1</em>, <em class="sig-param">axis2</em>, <em class="sig-param">optimize=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.swap_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps the axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis2</strong> (<em>axis1</em><em>,</em>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</p></li>
<li><p><strong>optimize</strong> (<em>bool</em>) – If True, the location of the data in memory is optimised for the
fastest iteration over the navigation axes. This operation can
cause a peak of memory usage and requires considerable processing
times for large datasets and/or low specification hardware.
See the <cite>transposing</cite> section of the HyperSpy user guide
for more information. When operating on lazy signals, if <cite>True</cite>
the chunks are optimised for the new axes configuration.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a copy of the object with the axes swapped.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><em class="sig-param">signal_axes=None</em>, <em class="sig-param">navigation_axes=None</em>, <em class="sig-param">optimize=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposes the signal to have the required signal and navigation
axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>navigation_axes</strong> (<em>signal_axes</em><em>,</em>) – With the exception of both parameters getting iterables, generally
one has to be None (i.e. “floating”). The other one specifies
either the required number or explicitly the axes to move to the
corresponding space.
If both are iterables, full control is given as long as all axes
are assigned to one space only.</p></li>
<li><p><strong>optimize</strong> (<em>bool</em>) – If True, the location of the data in memory is optimised for the
fastest iteration over the navigation axes. This operation can
cause a peak of memory usage and requires considerable processing
times for large datasets and/or low specification hardware.
See the <cite>transposing</cite> section of the HyperSpy user guide
for more information. When operating on lazy signals, if <cite>True</cite>
the chunks are optimised for the new axes configuration.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.T" title="hyperspy.signal.BaseSignal.T"><code class="xref py py-meth docutils literal notranslate"><span class="pre">T()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.as_signal2D" title="hyperspy.signal.BaseSignal.as_signal2D"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_signal2D()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.as_signal1D" title="hyperspy.signal.BaseSignal.as_signal1D"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_signal1D()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">hs.transpose()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># just create a signal with many distinct dimensions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;BaseSignal, title: , dimensions: (|9, 8, 7, 6, 5, 4, 3, 2, 1)&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="c1"># swap signal and navigation spaces</span>
<span class="go">&lt;BaseSignal, title: , dimensions: (9, 8, 7, 6, 5, 4, 3, 2, 1|)&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">T</span> <span class="c1"># a shortcut for no arguments</span>
<span class="go">&lt;BaseSignal, title: , dimensions: (9, 8, 7, 6, 5, 4, 3, 2, 1|)&gt;</span>
</pre></div>
</div>
<p># roll to leave 5 axes in navigation space
&gt;&gt;&gt; s.transpose(signal_axes=5)
&lt;BaseSignal, title: , dimensions: (4, 3, 2, 1|9, 8, 7, 6, 5)&gt;</p>
<p># roll leave 3 axes in navigation space
&gt;&gt;&gt; s.transpose(navigation_axes=3)
&lt;BaseSignal, title: , dimensions: (3, 2, 1|9, 8, 7, 6, 5, 4)&gt;</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 3 explicitly defined axes in signal space</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">signal_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">&lt;BaseSignal, title: , dimensions: (8, 6, 5, 4, 2, 1|9, 7, 3)&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># A mix of two lists, but specifying all axes explicitly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The order of axes is preserved in both lists</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">navigation_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">signal_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="go">&lt;BaseSignal, title: , dimensions: (8, 7, 6, 5, 4, 1|9, 3, 2)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.unfold">
<code class="sig-name descname">unfold</code><span class="sig-paren">(</span><em class="sig-param">unfold_navigation=True</em>, <em class="sig-param">unfold_signal=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.unfold" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies the shape of the data by unfolding the signal and
navigation dimensions separately</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>needed_unfolding</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.unfold_navigation_space">
<code class="sig-name descname">unfold_navigation_space</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.unfold_navigation_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify the shape of the data to obtain a navigation space of
dimension 1</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>needed_unfolding</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.unfold_signal_space">
<code class="sig-name descname">unfold_signal_space</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.unfold_signal_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify the shape of the data to obtain a signal space of
dimension 1</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>needed_unfolding</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.unfolded">
<code class="sig-name descname">unfolded</code><span class="sig-paren">(</span><em class="sig-param">unfold_navigation=True</em>, <em class="sig-param">unfold_signal=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.unfolded" title="Permalink to this definition">¶</a></dt>
<dd><p>Use this function together with a <cite>with</cite> statement to have the
signal be unfolded for the scope of the <cite>with</cite> block, before
automatically refolding when passing out of scope.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.unfold" title="hyperspy.signal.BaseSignal.unfold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unfold()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.fold" title="hyperspy.signal.BaseSignal.fold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">s</span><span class="o">.</span><span class="n">unfolded</span><span class="p">():</span>
<span class="go">        # Do whatever needs doing while unfolded here</span>
<span class="go">        pass</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.update_plot">
<code class="sig-name descname">update_plot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.update_plot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.valuemax">
<code class="sig-name descname">valuemax</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.valuemax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the value of coordinates of the maximum along an axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str or <cite>axis</cite>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>max, min, sum, mean, std, var, indexmax, amax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">valuemax</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.valuemin">
<code class="sig-name descname">valuemin</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.valuemin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the value of coordinates of the minimum along an axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str or <cite>axis</cite>) – The axis can be passed directly, or specified using the index of
the axis in <cite>axes_manager</cite> or the axis name.</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.max" title="hyperspy.signal.BaseSignal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.min" title="hyperspy.signal.BaseSignal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.sum" title="hyperspy.signal.BaseSignal.sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.mean" title="hyperspy.signal.BaseSignal.mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mean()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.std" title="hyperspy.signal.BaseSignal.std"><code class="xref py py-meth docutils literal notranslate"><span class="pre">std()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.var" title="hyperspy.signal.BaseSignal.var"><code class="xref py py-meth docutils literal notranslate"><span class="pre">var()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.indexmax" title="hyperspy.signal.BaseSignal.indexmax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">indexmax()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">amax()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.BaseSignal.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param">axis=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">rechunk=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.BaseSignal.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the variances of the signal along at least one
axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (int, str, <cite>axis</cite>, tuple of <cite>axis</cite> or None) – Either one on its own, or many axes in a tuple can be passed. In
both cases the axes can be passed directly, or specified using the
index in <cite>axes_manager</cite> or the name of the axis. Any duplicates are
removed. If None, the operation is performed over all navigation
axes (default).</p></li>
<li><p><strong>out</strong> (<cite>Signal</cite> or None) – If None, a new Signal is created with the result of the operation
and returned (default). If a Signal is passed, it is used to
receive the output of the operation, and nothing is returned.</p></li>
<li><p><strong>rechunk</strong> (<em>bool</em>) – Only has effect when operating on lazy signal. If <cite>True</cite> (default),
the data may be automatically rechunked before performing this operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>s</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Signal</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.BaseSignal.max" title="hyperspy.signal.BaseSignal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.min" title="hyperspy.signal.BaseSignal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.sum" title="hyperspy.signal.BaseSignal.sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.mean" title="hyperspy.signal.BaseSignal.mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mean()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.std" title="hyperspy.signal.BaseSignal.std"><code class="xref py py-meth docutils literal notranslate"><span class="pre">std()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.indexmax" title="hyperspy.signal.BaseSignal.indexmax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">indexmax()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.BaseSignal.valuemax" title="hyperspy.signal.BaseSignal.valuemax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">valuemax()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">amax()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">BaseSignal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="hyperspy.signal.COMPARISON_OPERATORS">
<code class="sig-prename descclassname">hyperspy.signal.</code><code class="sig-name descname">COMPARISON_OPERATORS</code><em class="property"> = ('__lt__', '__le__', '__eq__', '__ne__', '__ge__', '__gt__')</em><a class="headerlink" href="#hyperspy.signal.COMPARISON_OPERATORS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="data">
<dt id="hyperspy.signal.INPLACE_OPERATORS">
<code class="sig-prename descclassname">hyperspy.signal.</code><code class="sig-name descname">INPLACE_OPERATORS</code><em class="property"> = ('__iadd__', '__isub__', '__imul__', '__itruediv__', '__ifloordiv__', '__imod__', '__ipow__', '__ilshift__', '__irshift__', '__iand__', '__ixor__', '__ior__')</em><a class="headerlink" href="#hyperspy.signal.INPLACE_OPERATORS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="hyperspy.signal.MVATools">
<em class="property">class </em><code class="sig-prename descclassname">hyperspy.signal.</code><code class="sig-name descname">MVATools</code><a class="headerlink" href="#hyperspy.signal.MVATools" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="hyperspy.signal.MVATools.export_bss_results">
<code class="sig-name descname">export_bss_results</code><span class="sig-paren">(</span><em class="sig-param">comp_ids=None</em>, <em class="sig-param">folder=None</em>, <em class="sig-param">calibrate=True</em>, <em class="sig-param">multiple_files=True</em>, <em class="sig-param">save_figures=False</em>, <em class="sig-param">factor_prefix='bss_factor'</em>, <em class="sig-param">factor_format='hspy'</em>, <em class="sig-param">loading_prefix='bss_loading'</em>, <em class="sig-param">loading_format='hspy'</em>, <em class="sig-param">comp_label=None</em>, <em class="sig-param">cmap=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;</em>, <em class="sig-param">same_window=False</em>, <em class="sig-param">no_nans=True</em>, <em class="sig-param">per_row=3</em>, <em class="sig-param">save_figures_format='png'</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.export_bss_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Export results from ICA to any of the supported formats.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comp_ids</strong> (<em>None</em><em>, </em><em>int</em><em>, or </em><em>list of ints</em>) – <p>if None, returns all components/loadings.
if int, returns components/loadings with ids from 0 to given</p>
<blockquote>
<div><p>int.</p>
</div></blockquote>
<p>if list of ints, returns components/loadings with ids in
iven list.</p>
</p></li>
<li><p><strong>folder</strong> (<em>str</em><em> or </em><em>None</em>) – The path to the folder where the file will be saved. If
<cite>None</cite> the
current folder is used by default.</p></li>
<li><p><strong>factor_prefix</strong> (<em>string</em>) – The prefix that any exported filenames for
factors/components
begin with</p></li>
<li><p><strong>factor_format</strong> (<em>string</em>) – The extension of the format that you wish to save to. Default is
“hspy”. See <cite>loading format</cite> for more details.</p></li>
<li><p><strong>loading_prefix</strong> (<em>string</em>) – The prefix that any exported filenames for
factors/components
begin with</p></li>
<li><p><strong>loading_format</strong> (<em>string</em>) – <p>The extension of the format that you wish to save to. default
is “hspy”. The format determines the kind of output.
- For image formats (tif, png, jpg, etc.), plots are</p>
<blockquote>
<div><p>created using the plotting flags as below, and saved at
600 dpi. One plot per loading is saved.</p>
</div></blockquote>
<ul>
<li><p>For multidimensional formats (“rpl”, “hspy”), arrays are
saved in single files.  All loadings are contained in the
one file.</p></li>
<li><p>For spectral formats (msa), each loading is saved to a
separate file.</p></li>
</ul>
</p></li>
<li><p><strong>multiple_files</strong> (<em>Bool</em>) – If True, on exporting a file per factor and per loading
will be created. Otherwise only two files will be created, one
for the factors and another for the loadings. Default is True.</p></li>
<li><p><strong>save_figures</strong> (<em>Bool</em>) – If True the same figures that are obtained when using the
plot
methods will be saved with 600 dpi resolution</p></li>
<li><p><strong>options</strong><strong> (</strong><strong>for save_figures = True ONLY</strong><strong>)</strong> (<em>Plotting</em>) – </p></li>
<li><p><strong>----------------------------------------------</strong> – </p></li>
<li><p><strong>calibrate</strong> (<em>bool</em>) – if True, calibrates plots where calibration is available
from
the axes_manager.  If False, plots are in pixels/channels.</p></li>
<li><p><strong>same_window</strong> (<em>bool</em>) – if True, plots each factor to the same window.</p></li>
<li><p><strong>comp_label</strong> (<em>string</em>) – the label that is either the plot title (if plotting in
separate windows) or the label in the legend (if plotting
in the
same window)</p></li>
<li><p><strong>cmap</strong> (<em>The colormap used for the factor image</em><em>, or </em><em>for peak</em>) – characteristics, the colormap used for the scatter plot of
some peak characteristic.</p></li>
<li><p><strong>per_row</strong> (<em>int</em><em>, </em><em>the number of plots in each row</em><em>, </em><em>when the</em>) – </p></li>
<li><p><strong>same_window</strong> – parameter is True.</p></li>
<li><p><strong>save_figures_format</strong> (<em>str</em>) – The image format extension.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.MVATools.get_bss_factors" title="hyperspy.signal.MVATools.get_bss_factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_bss_factors()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_bss_loadings.()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.MVATools.export_decomposition_results">
<code class="sig-name descname">export_decomposition_results</code><span class="sig-paren">(</span><em class="sig-param">comp_ids=None</em>, <em class="sig-param">folder=None</em>, <em class="sig-param">calibrate=True</em>, <em class="sig-param">factor_prefix='factor'</em>, <em class="sig-param">factor_format='hspy'</em>, <em class="sig-param">loading_prefix='loading'</em>, <em class="sig-param">loading_format='hspy'</em>, <em class="sig-param">comp_label=None</em>, <em class="sig-param">cmap=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;</em>, <em class="sig-param">same_window=False</em>, <em class="sig-param">multiple_files=True</em>, <em class="sig-param">no_nans=True</em>, <em class="sig-param">per_row=3</em>, <em class="sig-param">save_figures=False</em>, <em class="sig-param">save_figures_format='png'</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.export_decomposition_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Export results from a decomposition to any of the supported
formats.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comp_ids</strong> (<em>None</em><em>, </em><em>int</em><em>, or </em><em>list of ints</em>) – if None, returns all components/loadings.
if int, returns components/loadings with ids from 0 to
given int.
if list of ints, returns components/loadings with ids in
given list.</p></li>
<li><p><strong>folder</strong> (<em>str</em><em> or </em><em>None</em>) – The path to the folder where the file will be saved.
If <cite>None</cite> the
current folder is used by default.</p></li>
<li><p><strong>factor_prefix</strong> (<em>string</em>) – The prefix that any exported filenames for
factors/components
begin with</p></li>
<li><p><strong>factor_format</strong> (<em>string</em>) – The extension of the format that you wish to save to. Default is
“hspy”. See <cite>loading format</cite> for more details.</p></li>
<li><p><strong>loading_prefix</strong> (<em>string</em>) – The prefix that any exported filenames for
factors/components
begin with</p></li>
<li><p><strong>loading_format</strong> (<em>string</em>) – <p>The extension of the format that you wish to save to. default
is “hspy”. The format determines the kind of output.
- For image formats (tif, png, jpg, etc.), plots are</p>
<blockquote>
<div><p>created using the plotting flags as below, and saved at
600 dpi. One plot per loading is saved.</p>
</div></blockquote>
<ul>
<li><p>For multidimensional formats (“rpl”, “hspy”), arrays are
saved in single files.  All loadings are contained in the
one file.</p></li>
<li><p>For spectral formats (msa), each loading is saved to a
separate file.</p></li>
</ul>
</p></li>
<li><p><strong>multiple_files</strong> (<em>bool</em>) – If True, on exporting a file per factor and per loading will
be created. Otherwise only two files will be created, one for
the factors and another for the loadings. The default value can
be chosen in the preferences.</p></li>
<li><p><strong>save_figures</strong> (<em>bool</em>) – If True the same figures that are obtained when using the plot
methods will be saved with 600 dpi resolution</p></li>
<li><p><strong>options</strong><strong> (</strong><strong>for save_figures = True ONLY</strong><strong>)</strong> (<em>Plotting</em>) – </p></li>
<li><p><strong>----------------------------------------------</strong> – </p></li>
<li><p><strong>calibrate</strong> (<em>bool</em>) – if True, calibrates plots where calibration is available
from
the axes_manager.  If False, plots are in pixels/channels.</p></li>
<li><p><strong>same_window</strong> (<em>bool</em>) – if True, plots each factor to the same window.</p></li>
<li><p><strong>comp_label</strong> (<em>string</em><em>, </em><em>the label that is either the plot title</em>) – (if plotting in separate windows) or the label in the legend
(if plotting in the same window)</p></li>
<li><p><strong>cmap</strong> (<em>The colormap used for the factor image</em><em>, or </em><em>for peak</em>) – characteristics, the colormap used for the scatter plot of
some peak characteristic.</p></li>
<li><p><strong>per_row</strong> (<em>int</em><em>, </em><em>the number of plots in each row</em><em>, </em><em>when the</em>) – </p></li>
<li><p><strong>same_window</strong> – parameter is True.</p></li>
<li><p><strong>save_figures_format</strong> (<em>str</em>) – The image format extension.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.MVATools.get_decomposition_factors" title="hyperspy.signal.MVATools.get_decomposition_factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_decomposition_factors()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_decomposition_loadings.()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.MVATools.get_bss_factors">
<code class="sig-name descname">get_bss_factors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.get_bss_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the blind source separtion factors as a Signal.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.MVATools.get_bss_loadings" title="hyperspy.signal.MVATools.get_bss_loadings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_bss_loadings()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">export_bss_results.()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.MVATools.get_bss_loadings">
<code class="sig-name descname">get_bss_loadings</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.get_bss_loadings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the blind source separtion loadings as a Signal.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.MVATools.get_bss_factors" title="hyperspy.signal.MVATools.get_bss_factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_bss_factors()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">export_bss_results.()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.MVATools.get_decomposition_factors">
<code class="sig-name descname">get_decomposition_factors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.get_decomposition_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the decomposition factors as a Signal.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.MVATools.get_decomposition_loadings" title="hyperspy.signal.MVATools.get_decomposition_loadings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_decomposition_loadings()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">export_decomposition_results.()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.MVATools.get_decomposition_loadings">
<code class="sig-name descname">get_decomposition_loadings</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.get_decomposition_loadings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the decomposition loadings as a Signal.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.MVATools.get_decomposition_factors" title="hyperspy.signal.MVATools.get_decomposition_factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_decomposition_factors()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">export_decomposition_results.()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.MVATools.plot_bss_factors">
<code class="sig-name descname">plot_bss_factors</code><span class="sig-paren">(</span><em class="sig-param">comp_ids=None</em>, <em class="sig-param">calibrate=True</em>, <em class="sig-param">same_window=True</em>, <em class="sig-param">comp_label=None</em>, <em class="sig-param">per_row=3</em>, <em class="sig-param">title=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.plot_bss_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot factors from blind source separation results. In case of 1D
signal axis, each factors line can be toggled on and off by clicking
on their corresponding line in the legend.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comp_ids</strong> (<em>None</em><em>, </em><em>int</em><em>, or </em><em>list of ints</em>) – if None, returns maps of all components.
if int, returns maps of components with ids from 0 to
given int.
if list of ints, returns maps of components with ids in
given list.</p></li>
<li><p><strong>calibrate</strong> (<em>bool</em>) – if True, calibrates plots where calibration is available
from
the axes_manager.  If False, plots are in pixels/channels.</p></li>
<li><p><strong>same_window</strong> (<em>bool</em>) – if True, plots each factor to the same window.  They are
not scaled. Default is True.</p></li>
<li><p><strong>title</strong> (<em>string</em>) – Title of the plot.</p></li>
<li><p><strong>cmap</strong> (<em>The colormap used for the factor image</em><em>, or </em><em>for peak</em>) – characteristics, the colormap used for the scatter plot of
some peak characteristic.</p></li>
<li><p><strong>per_row</strong> (<em>int</em><em>, </em><em>the number of plots in each row</em><em>, </em><em>when the</em>) – </p></li>
<li><p><strong>same_window</strong> – parameter is True.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.MVATools.plot_bss_loadings" title="hyperspy.signal.MVATools.plot_bss_loadings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bss_loadings()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bss_results.()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.MVATools.plot_bss_loadings">
<code class="sig-name descname">plot_bss_loadings</code><span class="sig-paren">(</span><em class="sig-param">comp_ids=None</em>, <em class="sig-param">calibrate=True</em>, <em class="sig-param">same_window=True</em>, <em class="sig-param">comp_label=None</em>, <em class="sig-param">with_factors=False</em>, <em class="sig-param">cmap=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;</em>, <em class="sig-param">no_nans=False</em>, <em class="sig-param">per_row=3</em>, <em class="sig-param">axes_decor='all'</em>, <em class="sig-param">title=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.plot_bss_loadings" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot loadings from blind source separation results. In case of 1D
navigation axis, each loading line can be toggled on and off by
clicking on their corresponding line in the legend.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comp_ids</strong> (<em>None</em><em>, </em><em>int</em><em>, or </em><em>list of ints</em>) – if None, returns maps of all components.
if int, returns maps of components with ids from 0 to
given int.
if list of ints, returns maps of components with ids in
given list.</p></li>
<li><p><strong>calibrate</strong> (<em>bool</em>) – if True, calibrates plots where calibration is available
from
the axes_manager.  If False, plots are in pixels/channels.</p></li>
<li><p><strong>same_window</strong> (<em>bool</em>) – if True, plots each factor to the same window.  They are
not scaled. Default is True.</p></li>
<li><p><strong>title</strong> (<em>string</em>) – Title of the plot.</p></li>
<li><p><strong>with_factors</strong> (<em>bool</em>) – If True, also returns figure(s) with the factors for the
given comp_ids.</p></li>
<li><p><strong>cmap</strong> (<em>matplotlib colormap</em>) – The colormap used for the factor image, or for peak
characteristics, the colormap used for the scatter plot of
some peak characteristic.</p></li>
<li><p><strong>no_nans</strong> (<em>bool</em>) – If True, removes NaN’s from the loading plots.</p></li>
<li><p><strong>per_row</strong> (<em>int</em>) – the number of plots in each row, when the same_window
parameter is True.</p></li>
<li><p><strong>axes_decor</strong> (<em>{'all'</em><em>, </em><em>'ticks'</em><em>, </em><em>'off'</em><em>, </em><em>None}</em><em>, </em><em>optional</em>) – Controls how the axes are displayed on each image; default is ‘all’
If ‘all’, both ticks and axis labels will be shown
If ‘ticks’, no axis labels will be shown, but ticks / labels will
If ‘off’, all decorations and frame will be disabled
If None, no axis decorations will be shown, but ticks/frame will</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.MVATools.plot_bss_factors" title="hyperspy.signal.MVATools.plot_bss_factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bss_factors()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bss_results.()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.MVATools.plot_bss_results">
<code class="sig-name descname">plot_bss_results</code><span class="sig-paren">(</span><em class="sig-param">factors_navigator='smart_auto'</em>, <em class="sig-param">loadings_navigator='smart_auto'</em>, <em class="sig-param">factors_dim=2</em>, <em class="sig-param">loadings_dim=2</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.plot_bss_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the blind source separation factors and loadings.</p>
<p>Unlike <cite>plot_bss_factors</cite> and <cite>plot_bss_loadings</cite>, this method displays
one component at a time. Therefore it provides a more compact
visualization than then other two methods.  The loadings and factors
are displayed in different windows and each has its own
navigator/sliders to navigate them if they are multidimensional. The
component index axis is synchronized between the two.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loadings_navigator</strong> (<em>factors_navigator</em><em>,</em>) – </p></li>
<li><p><strong>Signal}</strong> – “smart_auto” (default) displays sliders if the navigation
dimension is less than 3. For a description of the other options
see <cite>plot</cite> documentation for details.</p></li>
<li><p><strong>loadings_dim</strong> (<em>factors_dim</em><em>,</em>) – Currently HyperSpy cannot plot signals of dimension higher than
two. Therefore, to visualize the BSS results when the
factors or the loadings have signal dimension greater than 2
we can view the data as spectra(images) by setting this parameter
to 1(2). (Default 2)</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.MVATools.plot_bss_factors" title="hyperspy.signal.MVATools.plot_bss_factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bss_factors()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.MVATools.plot_bss_loadings" title="hyperspy.signal.MVATools.plot_bss_loadings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bss_loadings()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_decomposition_results.()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.MVATools.plot_decomposition_factors">
<code class="sig-name descname">plot_decomposition_factors</code><span class="sig-paren">(</span><em class="sig-param">comp_ids=None</em>, <em class="sig-param">calibrate=True</em>, <em class="sig-param">same_window=True</em>, <em class="sig-param">comp_label=None</em>, <em class="sig-param">cmap=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;</em>, <em class="sig-param">per_row=3</em>, <em class="sig-param">title=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.plot_decomposition_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot factors from a decomposition. In case of 1D signal axis, each
factors line can be toggled on and off by clicking on their
corresponding line in the legend.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comp_ids</strong> (<em>None</em><em>, </em><em>int</em><em>, or </em><em>list of ints</em>) – if None (default), returns maps of all components if the output_dimension was defined when
executing <code class="docutils literal notranslate"><span class="pre">decomposition</span></code>. Otherwise it raises a ValueError.
if int, returns maps of components with ids from 0 to
given int.
if list of ints, returns maps of components with ids in
given list.</p></li>
<li><p><strong>calibrate</strong> (<em>bool</em>) – if True, calibrates plots where calibration is available
from
the axes_manager.  If False, plots are in pixels/channels.</p></li>
<li><p><strong>same_window</strong> (<em>bool</em>) – if True, plots each factor to the same window.  They are
not scaled. Default is True.</p></li>
<li><p><strong>title</strong> (<em>string</em>) – Title of the plot.</p></li>
<li><p><strong>cmap</strong> (<em>The colormap used for the factor image</em><em>, or </em><em>for peak</em>) – characteristics, the colormap used for the scatter plot of
some peak characteristic.</p></li>
<li><p><strong>per_row</strong> (<em>int</em><em>, </em><em>the number of plots in each row</em><em>, </em><em>when the</em>) – </p></li>
<li><p><strong>parameter is True.</strong> (<em>same_window</em>) – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.MVATools.plot_decomposition_loadings" title="hyperspy.signal.MVATools.plot_decomposition_loadings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_decomposition_loadings()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_decomposition_results.()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.MVATools.plot_decomposition_loadings">
<code class="sig-name descname">plot_decomposition_loadings</code><span class="sig-paren">(</span><em class="sig-param">comp_ids=None</em>, <em class="sig-param">calibrate=True</em>, <em class="sig-param">same_window=True</em>, <em class="sig-param">comp_label=None</em>, <em class="sig-param">with_factors=False</em>, <em class="sig-param">cmap=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;</em>, <em class="sig-param">no_nans=False</em>, <em class="sig-param">per_row=3</em>, <em class="sig-param">axes_decor='all'</em>, <em class="sig-param">title=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.plot_decomposition_loadings" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot loadings from a decomposition. In case of 1D navigation axis,
each loading line can be toggled on and off by clicking on the legended
line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comp_ids</strong> (<em>None</em><em>, </em><em>int</em><em>, or </em><em>list of ints</em>) – if None (default), returns maps of all components if the output_dimension was defined when
executing <code class="docutils literal notranslate"><span class="pre">decomposition</span></code>. Otherwise it raises a ValueError.
if int, returns maps of components with ids from 0 to
given int.
if list of ints, returns maps of components with ids in
given list.</p></li>
<li><p><strong>calibrate</strong> (<em>bool</em>) – if True, calibrates plots where calibration is available
from the axes_manager. If False, plots are in pixels/channels.</p></li>
<li><p><strong>same_window</strong> (<em>bool</em>) – if True, plots each factor to the same window.  They are
not scaled. Default is True.</p></li>
<li><p><strong>title</strong> (<em>string</em>) – Title of the plot.</p></li>
<li><p><strong>with_factors</strong> (<em>bool</em>) – If True, also returns figure(s) with the factors for the
given comp_ids.</p></li>
<li><p><strong>cmap</strong> (<em>matplotlib colormap</em>) – The colormap used for the factor image, or for peak
characteristics, the colormap used for the scatter plot of
some peak characteristic.</p></li>
<li><p><strong>no_nans</strong> (<em>bool</em>) – If True, removes NaN’s from the loading plots.</p></li>
<li><p><strong>per_row</strong> (<em>int</em>) – the number of plots in each row, when the same_window
parameter is True.</p></li>
<li><p><strong>axes_decor</strong> (<em>{'all'</em><em>, </em><em>'ticks'</em><em>, </em><em>'off'</em><em>, </em><em>None}</em><em>, </em><em>optional</em>) – Controls how the axes are displayed on each image; default is ‘all’
If ‘all’, both ticks and axis labels will be shown
If ‘ticks’, no axis labels will be shown, but ticks/labels will
If ‘off’, all decorations and frame will be disabled
If None, no axis decorations will be shown, but ticks/frame will</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.MVATools.plot_decomposition_factors" title="hyperspy.signal.MVATools.plot_decomposition_factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_decomposition_factors()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_decomposition_results.()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.MVATools.plot_decomposition_results">
<code class="sig-name descname">plot_decomposition_results</code><span class="sig-paren">(</span><em class="sig-param">factors_navigator='smart_auto'</em>, <em class="sig-param">loadings_navigator='smart_auto'</em>, <em class="sig-param">factors_dim=2</em>, <em class="sig-param">loadings_dim=2</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.MVATools.plot_decomposition_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the decompostion factors and loadings.</p>
<p>Unlike <cite>plot_factors</cite> and <cite>plot_loadings</cite>, this method displays
one component at a time. Therefore it provides a more compact
visualization than then other two methods.  The loadings and factors
are displayed in different windows and each has its own
navigator/sliders to navigate them if they are multidimensional. The
component index axis is synchronized between the two.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loadings_navigator</strong> (<em>factors_navigator</em><em>,</em>) – </p></li>
<li><p><strong>Signal}</strong> – “smart_auto” (default) displays sliders if the navigation
dimension is less than 3. For a description of the other options
see <cite>plot</cite> documentation for details.</p></li>
<li><p><strong>loadings_dim</strong> (<em>factors_dim</em><em>,</em>) – Currently HyperSpy cannot plot signals of dimension higher than
two. Therefore, to visualize the BSS results when the
factors or the loadings have signal dimension greater than 2
we can view the data as spectra(images) by setting this parameter
to 1(2). (Default 2)</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_factors()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_loadings()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bss_results.()</span></code></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy.signal.ModelManager">
<em class="property">class </em><code class="sig-prename descclassname">hyperspy.signal.</code><code class="sig-name descname">ModelManager</code><span class="sig-paren">(</span><em class="sig-param">signal</em>, <em class="sig-param">dictionary=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.ModelManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Container for models</p>
<dl class="class">
<dt id="hyperspy.signal.ModelManager.ModelStub">
<em class="property">class </em><code class="sig-name descname">ModelStub</code><span class="sig-paren">(</span><em class="sig-param">mm</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.ModelManager.ModelStub" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.ModelManager.pop">
<code class="sig-name descname">pop</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.ModelManager.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the restored model and removes it from storage</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>string</em>) – the name of the model to restore and remove</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.ModelManager.restore" title="hyperspy.signal.ModelManager.restore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">restore()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.ModelManager.store" title="hyperspy.signal.ModelManager.store"><code class="xref py py-meth docutils literal notranslate"><span class="pre">store()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.ModelManager.remove" title="hyperspy.signal.ModelManager.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.ModelManager.remove">
<code class="sig-name descname">remove</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.ModelManager.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the given model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>string</em>) – the name of the model to remove</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.ModelManager.restore" title="hyperspy.signal.ModelManager.restore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">restore()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.ModelManager.store" title="hyperspy.signal.ModelManager.store"><code class="xref py py-meth docutils literal notranslate"><span class="pre">store()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.ModelManager.pop" title="hyperspy.signal.ModelManager.pop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.ModelManager.restore">
<code class="sig-name descname">restore</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.ModelManager.restore" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the restored model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>string</em>) – the name of the model to restore</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.ModelManager.remove" title="hyperspy.signal.ModelManager.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.ModelManager.store" title="hyperspy.signal.ModelManager.store"><code class="xref py py-meth docutils literal notranslate"><span class="pre">store()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.ModelManager.pop" title="hyperspy.signal.ModelManager.pop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy.signal.ModelManager.store">
<code class="sig-name descname">store</code><span class="sig-paren">(</span><em class="sig-param">model</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.ModelManager.store" title="Permalink to this definition">¶</a></dt>
<dd><p>If the given model was created from this signal, stores it</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>model</em>) – the model to store in the signal</p></li>
<li><p><strong>name</strong> (<em>{string</em><em>, </em><em>None}</em>) – the name for the model to be stored with</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#hyperspy.signal.ModelManager.remove" title="hyperspy.signal.ModelManager.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.ModelManager.restore" title="hyperspy.signal.ModelManager.restore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">restore()</span></code></a>, <a class="reference internal" href="#hyperspy.signal.ModelManager.pop" title="hyperspy.signal.ModelManager.pop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="hyperspy.signal.SpecialSlicersSignal">
<em class="property">class </em><code class="sig-prename descclassname">hyperspy.signal.</code><code class="sig-name descname">SpecialSlicersSignal</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">isNavigation</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy.signal.SpecialSlicersSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hyperspy.misc.slicing.html#hyperspy.misc.slicing.SpecialSlicers" title="hyperspy.misc.slicing.SpecialSlicers"><code class="xref py py-class docutils literal notranslate"><span class="pre">hyperspy.misc.slicing.SpecialSlicers</span></code></a></p>
</dd></dl>

<dl class="data">
<dt id="hyperspy.signal.UNARY_OPERATORS">
<code class="sig-prename descclassname">hyperspy.signal.</code><code class="sig-name descname">UNARY_OPERATORS</code><em class="property"> = ('__neg__', '__pos__', '__abs__', '__invert__')</em><a class="headerlink" href="#hyperspy.signal.UNARY_OPERATORS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="hyperspy.signal_tools.html" class="btn btn-neutral float-right" title="hyperspy.signal_tools module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="hyperspy.samfire.html" class="btn btn-neutral" title="hyperspy.samfire module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2011-2018, The HyperSpy development team

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>